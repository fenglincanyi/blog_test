[{"title":"View 测量相关总结","date":"2017-08-11T05:18:00.000Z","path":"2017/08/11/View 测量相关总结/","text":"ViewGroup的测量过程ViewGroup 没有重写 View 的 measure() 和 onMeasure() 方法，沿用的还是View的 然后在 View 的源码中，我们找到 measure()，它内部调用到 onMeasure()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent */public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ...... long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; // 解析 layout、padding、drawable 相关参数 resolveRtlPropertiesIfNeeded(); int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException(\"View with id \" + getId() + \": \" + getClass().getName() + \"#onMeasure() did not set the\" + \" measured dimension by calling\" + \" setMeasuredDimension()\"); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension&#125; 其中，方法内传入的2个参数：widthMeasureSpec、heightMeasureSpec 也原封不动的传给 onMeasure() 方法中。 那 widthMeasureSpec，heightMeasureSpec 又是什么东西呢，我们从注释中看到：是 父View提供给子View(当前的view)宽高的约束信息，即：父View根据自己的宽高、内边距信息计算合成的值，提供给子View自己测量时候使用，作为一个建议值，不是父View的宽高信息从哪里能看出呢？我们找到ViewGroup的源码：1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 那么，widthMeasureSpec 和 heightMeasureSpec 具体又代表测量信息的什么呢？我们再看看 MeasureSpec(View 中的静态类)，发现，里面有 mode 和 size，mode 是测量模式（3中，不再细说，大家都知道），size 是测量大小，并且提供了 makeMeasureSpec() 和 getMode() ，getSize() 方法。measureSpec 这个东西是由 mode 和 size 合成的一个值，合成方法就是依靠 makeMeasureSpec() 来做位运算生成的。然后View和ViewGroup 会拿着它作为参数传递的。 measureSpec 是携带了测量模式和测量大小信息的一个值 getChildMeasureSpec() 是个具有Android View 测量方法论的一个方法，必须要知道。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec);// 父View的测量信息 int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 然后这个方法内，最后一步，也是将 mode 和 size 合成 measureSpec，并返回给 childWidthMeasureSpec。所以，我们在自定义View中可能会重写onMeasure方法时，要想知道 测量模式 mode 和大小，则必须通过getMode()、getSize()来获取。我们再看看View的 onMeasure() ： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 这里的 getDefaultSize() 方法，他也是这么做的:123456789101112131415161718public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; // 数值：AT_MOST(-2147483648) EXACTLY(1073741824) UNSPECIFIED(0)&#125; onMeasure() 被重写时，一定要调用 setMeasuredDimension() 方法为什么一定要这么做呢，我们先来看看 这个方法干了什么？1234567private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; // 赋值给测量宽高变量，并设置标志位的值 mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; 再回到View的measure()方法，发现：如果mPrivateFlags没有被设置的话，会抛出异常。那么，后面的mMeasureCache的put操作也就更新不了里面的值。这个缓存是个比较关键的东西，间接存储了测量的宽高信息。我们知道，一个View的测量操作是需要进行多次的(正常情况下3次measure，2次layout，1次draw)，所以这个存储就记录了当前测量结果的信息，下一次进行测量的时候，也是需要读取上次的信息，再判断如何进行下次测量操作的。从measure()方法中能看到，需要读取到缓存中的值。在重新请求测量View时，也会清空缓存，到测量时自己再创建新的缓存对象。如：requestLayout()方法这个LongSparseLongArray数据结构，使用形式上和map类似，但是它更省内存，也避免了装箱拆箱的操作，也不需要额外的entry。Google 也提倡使用此类的 array 来代替 HashMap 在Android中的使用，其他类似的array大家也都知道 123456789/** * LongSparseLongArray: * * Map of &#123;@code long&#125; to &#123;@code long&#125;. Unlike a normal array of longs, there * can be gaps in the indices. It is intended to be more memory efficient than using a * &#123;@code HashMap&#125;, both because it avoids * auto-boxing keys and values and its data structure doesn't rely on an extra entry object * for each mapping. */ onMeasure()被重写时，wrap_content 的功能需要自己实现如果不单独对 AT_MOST 做处理，在使用的时候设置 wrap_content,效果也就是和 match_parent 等价的。为什么呢? 还是分析 getChildMeasureSpec() 方法:此时 childDimension 为 wrap_content，其测量结果 resultSize = size(specSize - padding, 父View的测量尺寸大小 或 父View剩余可用空间)所以，我们可能按需求要对自定义的View，测量时，AT_MOST情况做处理了，我们可以对其设置一个默认的宽高值。这样写：1234567891011121314151617private int defaultWidth, defaultHeight;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthSpec = MeasureSpec.getMode(widthMeasureSpec); int heightSpec = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpec == MeasureSpec.AT_MOST &amp;&amp; heightSpec == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(defaultWidth, defaultHeight); &#125; else if (widthSpec == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(defaultWidth, widthSize); &#125; else if (heightSpec == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSize, defaultHeight); &#125;&#125; View 的测量方法是由它的父View发起的View 自己并不能主动发起测量，都是由父View或外界调用requestLayout()来调View的测量。ViewGroup会对自己所有的子View调起来测量的过程，父View对所有的子View 测量完毕后，再测量自己 Android 测量起始由ViewRoot执行开始从 ViewRootImpl 的performTraversals 开始，首先调用测量相关方法，ViewRootImpl的performMeasure方法，方法中会调用 ViewGroup measure方法，ViewGroup再对子View进行测量，如此递归下去，知道完成测量 附：https://developer.android.com/reference/android/view/ViewGroup.htmlhttp://blog.csdn.net/u012422440/article/details/52972825","tags":[{"name":"View","slug":"View","permalink":"https://fenglincanyi.github.io/tags/View/"},{"name":"Measure","slug":"Measure","permalink":"https://fenglincanyi.github.io/tags/Measure/"}]},{"title":"滑动相关 ScrollView & ListView","date":"2017-07-30T03:13:00.000Z","path":"2017/07/30/滑动相关 ScrollView & ListView/","text":"ScrollView 嵌套 ListView 问题分析滑动冲突的问题ScrollView 中嵌套 ListView，ListView 在测量时，高度不论写活还是写死，Listiew 的测量模式都是 不确定模式：unspecified ScrollView 换成 LinearLayout后： 经过上面的实验，什么原因造成的 heightMeasureSpec的值是 680 呢？ 追踪过程 在ScrollView 测量时： Listview 测量时：heightMeasureSpec = 680 再继续向前追溯：ScrollView的 onMeasure() 调用了父类的 onMeasure() 即 FrameLayout 的： 再仔细观察： 可以再查看ScrollView 的 measureChild() 方法，也是通过 设置 高度的测量模式：unspecified 我们对比 未覆盖的 ViewGroup的代码：1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 到最后，传到listview的 onMeasure 中后，我们来分析：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Sets up mListPadding super.onMeasure(widthMeasureSpec, heightMeasureSpec); final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec);// heightMeasureSpec：680 计算结果： heightMode：0 int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childWidth = 0; int childHeight = 0; int childState = 0; mItemCount = mAdapter == null ? 0 : mAdapter.getCount(); if (mItemCount &gt; 0 &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) &#123; final View child = obtainView(0, mIsScrap); // Lay out child directly against the parent measure spec so that // we can obtain exected minimum width and height. measureScrapChild(child, 0, widthMeasureSpec, heightSize); childWidth = child.getMeasuredWidth(); childHeight = child.getMeasuredHeight();// listview 的 item 高度 childState = combineMeasuredStates(childState, child.getMeasuredState()); if (recycleOnMeasure() &amp;&amp; mRecycler.shouldRecycleViewType( ((LayoutParams) child.getLayoutParams()).viewType)) &#123; mRecycler.addScrapView(child, 0); &#125; &#125; if (widthMode == MeasureSpec.UNSPECIFIED) &#123; widthSize = mListPadding.left + mListPadding.right + childWidth + getVerticalScrollbarWidth(); &#125; else &#123; widthSize |= (childState &amp; MEASURED_STATE_MASK); &#125; if (heightMode == MeasureSpec.UNSPECIFIED) &#123;// 符合条件 heightSize = mListPadding.top + mListPadding.bottom + childHeight + getVerticalFadingEdgeLength() * 2;// 所以 listview 的高度为 item 的高度 &#125; // 此种布局下，不管如何调整高度属性， listview 的 高度 测量规格始终都是 unspecified， if (heightMode == MeasureSpec.AT_MOST) &#123; // TODO: after first layout we should maybe start at the first visible position, not 0 heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1); &#125; setMeasuredDimension(widthSize, heightSize); mWidthMeasureSpec = widthMeasureSpec;&#125; 解决高度显示的问题 方法挺多的，这里给出一种：重写listview的onMesasurehttps://stackoverflow.com/questions/18367522/android-list-view-inside-a-scroll-view对于 ScrollView 的子View ，也不能配置高度属性为 match_parent, 即使设置了，也是按照 wrap_content 的效果走的而且 Android Studio 在lint 检查的时候，已经建议你这样做了 ScrollView 的滑动相关onTouchEvent 中，move 时：12345678910111213141516171819202122232425262728293031if (mIsBeingDragged) &#123; // Scroll to follow the motion event mLastMotionY = y - mScrollOffset[1]; final int oldY = mScrollY; final int range = getScrollRange(); final int overscrollMode = getOverScrollMode(); boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; range &gt; 0); // Calling overScrollBy will call onOverScrolled, which // calls onScrollChanged if applicable. if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true) &amp;&amp; !hasNestedScrollingParent()) &#123; // Break our velocity if we hit a scroll barrier. mVelocityTracker.clear(); &#125; ... ...&#125;private int getScrollRange() &#123; int scrollRange = 0; if (getChildCount() &gt; 0) &#123; View child = getChildAt(0); scrollRange = Math.max(0, child.getHeight() - (getHeight() - mPaddingBottom - mPaddingTop)); // 可滑动的范围： 子view的高度 - ScrollView 的高度（去掉上下内边距的） &#125; return scrollRange;&#125; 这里，曾经遇到过的问题： 想在 ScrollView 中滑到底部后，多滑动一部分距离来显示上面的距离，因为上层盖有view, 想做出透明的效果，如主页 tab + 列表的呈现方式；这时候可以这样处理：重写 addView() , 并把唯一的子View 添加一个 bottomPadding，就是增大 child.Hegiht. 所以增大了 ScrollRange； 类比：listview ，可以增加 一个有高度 的footer ,实现这种功能 滑动冲突的问题 解决办法1234567listView.setOnTouchListener(object : View.OnTouchListener &#123; override fun onTouch(v: View, event: MotionEvent): Boolean &#123; v.parent.parent.requestDisallowInterceptTouchEvent(true) return false; &#125;&#125;)// 请求 父view 不允许拦截，则交给 listview 来处理 move 事件 另外，ScrollView嵌套RecyclerView也会存在显示不全的问题 翻开历史新篇章： V4包 中提供了 可支持嵌套滑动的 ScrollView：NestedScrollView 我们再试试 NestedScrollView + ListView Listview 高度：wrap_content ，和上面的情况一样，listview的高度就是一条 item的gaoud Listview 高度：200dp , 则能全部显示出来 如图： 我们再换用NestedScrollView嵌套RecyclerView不会存在显示不全的问题; google 已经帮我们处理好了 继续测试： recyclerView 高度：wrap_content recyclerView 高度：200dp 分别如图：wrap_content 时，RecycleView 会全部显示出来 实现细节，可以看看 NestedScrollView 和 RecyclerView 的 measure 的处理方式 总结ScrollView 嵌套 Listview 存在以下问题： Listview 高度显示不全，就是因为 ScrollView 测量子View 的高度时，是 不确定 模式，导致Listview 绘制时候，不能确定高度，所以显示 item 的高度 滑动冲突，Listview滑动并不能响应，会被ScrollView拦截响应。 Listview 复用失效，由于Listview的高度不能确定，则会使屏幕内能够显示的 view 数量不能确定，然后就会不停的 getView()，导致所有的 item 都被创建出来了； RecyclerView 也会出现这类问题 ListView 在使用 父布局的时候，尽量避免使用RelatvieLayout，因为它的测量、布局过程比 LinearLayout 要多进行几次，就是因为，依赖关系的复杂过程的处理 NestedScrollView 的特性： 改变了事件传递的性质；原来的事件传递，都是由单个 View 去处理、消费的，而 增加了 嵌套滑动的事件处理机制后，父View和子View就可以同时处理一个事件 借助于 NestedScrollingParentHelper，NestedScrollingChildHelper 来进行事件的传递调用、信息分发和接收，使得父子view 的滑动信息都能获取到，并做相应的节点处理，控制更加自如 参考 https://github.com/android-cn/android-open-project-analysis/tree/master/tech/viewdrawflowhttp://blog.csdn.net/hanhailong726188/article/details/46136569https://stackoverflow.com/questions/18367522/android-list-view-inside-a-scroll-viewhttps://www.zhihu.com/question/34015543http://www.chenglong.ren/2016/11/14/android%E4%B8%ADnestedscrollview%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[{"name":"滑动","slug":"滑动","permalink":"https://fenglincanyi.github.io/tags/滑动/"},{"name":"ScrollView","slug":"ScrollView","permalink":"https://fenglincanyi.github.io/tags/ScrollView/"},{"name":"ListView","slug":"ListView","permalink":"https://fenglincanyi.github.io/tags/ListView/"}]},{"title":"Vue 从入门到搬砖","date":"2017-07-19T05:10:00.000Z","path":"2017/07/19/Vue 从入门到搬砖/","text":"前言前段时间，捣鼓weex，就想到对vue有所了解。毕竟weex是从vue的基础上扩展而来，诸多特性也是vue的。作为目前前端比较火的框架之一，有所了解，也是有一定好处的，所谓”多不压身”。Vue涵盖的不仅是一种前端框架，而且是前端生态的一系列设计思想、工具、规范。本文直奔主题，什么装环境、hello world 之类的琐事就略过…… 几个重要概念构造器每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的：12345var vm = new Vue(&#123; // 属性 // 方法 // 各种选项对象...&#125;) 在 vue 实例的基础上，提供了一些扩展的接口： 12Vue.extend(&#123;&#125;) 定义自己的组件，复用到不同的页面中，自底向上地构建页面应用。 Virtual DOMDOM：文档对象模型Virtual DOM 是个什么鬼？初学前端时，我们会直接用 js 去获取 dom 节点，拿到节点的属性和方法进行操作。但是这种操作性能比较差。虚拟DOM：就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 大致过程： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 数据绑定Vue 几乎屏蔽了直接通过操作 dom 更新的方式，更是趋向于 “数据的更新” 来达到 “视图的更新”。Vue 实例的 data 的相关字段更新后，与之使用到的视图中也随之更新，重新渲染。Vue 在不同组件间强制使用单向数据流。父组件通过 prop 向子组件赋值数据，子组件反过来向父组件 emit 发送事件 生命周期钩子123456789101112var LIFECYCLE_HOOKS = [ 'beforeCreate',//el 和 data 并未初始化 'created',// data 初始化 'beforeMount',// el 初始化 'mounted',// 完成挂载 'beforeUpdate',// 数据完成更新 'updated',// virtual dom 更新并重新渲染 'beforeDestroy',// vue 实例调用 desotry 'destroyed',// 移除组件、事件、监听 'activated',// 完成激活子组件 'deactivated'// 停用释放子组件]; 语法概览文本数据绑定，使用 mustache 语法： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; js 表达式： 12&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125; 指令123&lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; 过滤器1&#123;&#123; message | capitalize &#125;&#125; 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; 计算属性123&lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 123&lt;div id=\"example\"&gt; &#123;&#123; reversedMessage &#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125; &#125;&#125;) 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 样式绑定12&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt;&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 多个样式之间的切换，可以在 data 中定义： 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 条件渲染1234&lt;v-if&gt;&lt;v-else&gt;&lt;v-else-if&gt;&lt;v-show&gt; v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 列表渲染1&lt;v-for&gt; key使用当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。 数组更新检测由于 JavaScript 的限制， Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如： vm.items.length = newLength解决：Vue.set(example1.items, indexOfItem, newValue) 或 example1.items.splice(indexOfItem, 1, newValue)example1.items.splice(newLength)组件 12345678// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 1234&lt;!--使用--&gt;&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 组件通信 单项数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来 过渡效果配合 css 实现动画效果，元素的出现和消息过渡动画也是非常有意思的 v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 12用 包裹 view 动画元素&lt;transition name=\"xxx\"&gt;&lt;/transition&gt; 路由：vue-routerhttps://router.vuejs.org/zh-cn/ 1234567&lt;div id=\"app\"&gt; &lt;!--将来被替换的区域--&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;!--点击跳转配置，可传参数--&gt;&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt; 其他推荐饿了么组件库：http://element.eleme.io/#/zh-CNvue 网络库：axios：https://github.com/mzabriskie/axios 附录Demo:https://github.com/fenglincanyi/VueDemo1https://github.com/fenglincanyi/VueDemo2 参考：https://www.zhihu.com/question/29504639https://segmentfault.com/a/1190000008010666","tags":[{"name":"vue","slug":"vue","permalink":"https://fenglincanyi.github.io/tags/vue/"}]},{"title":"Android 7.0适配","date":"2017-06-09T12:10:00.000Z","path":"2017/06/09/Android 7.0适配/","text":"Android 7.0 行为变更，涉及：电池和内存、后台优化、权限更改、NDK 应用链接至平台库。 作为开发者，我们要关注 权限更改、NDK私有库的问题，适配工作也是围绕这2者展开。 分享私有文件的方式传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider 此类问题，我们要看 关注 拍照、覆盖安装。原先的拍照，我们一般这样写： 12345678910public static void startCamera(Activity tag, String fileName) &#123; if (!FileUtil.isSDMounted()) &#123; ToastUtil.showShortToast(tag, \"未挂载SD卡....\"); return; &#125; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File( getExternalStorageDirectory(), fileName))); tag.startActivityForResult(intent, PHOTO_REQUEST_TAKEPHOTO); &#125; 如果 适配到 7.0以上（targetSdkVersion &gt;= 24），上面就会出错：FileUriExposedExceptionGoogle 也是越来越注重安全的升级了，不让使用这种方式。现在要通过 provider 来进行访问，由 FileProvider 统一去访问相关的目录、文件。那具体，我们就看看怎么做： 定义FileProvider在清单文件中，添加 provider： 1234567891011121314&lt;provider android:name=\"android.support.v4.content.FileProvider\" android:authorities=\"com.chinahr.android.m.fileprovider\" android:exported=\"false\" android:grantUriPermissions=\"true\"&gt; &lt;!-- name：一般是固定的，如果你不需要定义自己的 provider; 如果需要别的特殊逻辑，你需要自定义 provider 去继承 v4 包下的 FileProvider并添加自己的逻辑代码， 那么这时候，name 就是你自定义的 provider的全路径了 authorities: packageName.fileprovider --&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/fileprovider\" /&gt;&lt;!-- file path 配置文件的路径 --&gt; &lt;/provider&gt; 配置路径文件在固定的目录下，res/xml 目录下，新建自己的 xml。 然后我们开始配置，如何配置呢，我们来看看官方文档的要求： 12345&lt;paths xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 可以配置多个 --&gt; &lt;files-path name=\"my_images\" path=\"images/\"/&gt; ...&lt;/paths&gt; 主要有4种路径： path dir files-path Context.getFilesDir() cache-path Context.getCacheDir) external-path name=”name” path=”path” Environment.getExternalStorageDirectory() external-cache-path name=”name” path=”path” Context.getExternalCacheDir() 那我们来个demo：在 xml 文件中配置： 12345&lt;paths&gt; &lt;external-path name=\"takephoto\" path=\"tmp\" /&gt; &lt;external-path name=\"apk\" path=\"Download\" /&gt; &lt;cache-path name=\"images\" path=\"/\" /&gt;&lt;/paths&gt; 代表的含义就是：在 sd 下的 tmp目录，Download目录下对应 拍照后存储目录、apk下载的目录在 packageName/cache 目录下存放app里的图片 配置工作，就ok了，现在解决拍照、覆盖安装崩溃的问题： 12345678910111213141516171819public static void startCameraN(Activity tag, String fileName) &#123; if (!FileUtil.isSDMounted()) &#123; ToastUtil.showShortToast(tag, \"未挂载SD卡....\"); return; &#125; // 必须和 xml 配置的 path 一致 File file = new File(getExternalStorageDirectory(), \"tmp/\"+fileName); Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); Uri pictureUri; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; pictureUri = FileProvider.getUriForFile(tag, tag.getPackageName()+\".fileprovider\", file); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);// 加上权限，否则也是要出错的 &#125; else &#123; pictureUri = Uri.fromFile(file); &#125; intent.putExtra(MediaStore.EXTRA_OUTPUT, pictureUri); tag.startActivityForResult(intent, PHOTO_REQUEST_TAKEPHOTO); &#125; 这样，我们就适配结束了 对于覆盖安装，同样的方式： 123456789101112Intent installIntent = new Intent(Intent.ACTION_VIEW); Uri apkUri; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; installIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); apkUri = FileProvider.getUriForFile(BaseAppUpdateActivity.this, getPackageName()+\".fileprovider\", apkFile); &#125; else &#123; apkUri = Uri.parse(\"file://\" + apkFile.toString()); &#125; installIntent.setDataAndType(apkUri, \"application/vnd.android.package-archive\"); startActivity(installIntent); //退出整个app finishAllActivity(); 具体可以看看文档：https://developer.android.com/reference/android/support/v4/content/FileProvider.html?hl=zh-cn 使用 NDK 私有链接库的问题从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，这种库可能会导致您的应用崩溃。此行为变更旨在为跨平台更新和不同设备提供统一的应用体验。即使您的代码可能不会链接私有库，但您的应用中的第三方静态库可能会这么做。因此，所有开发者都应进行相应检查，确保他们的应用不会在运行 Android 7.0 的设备上崩溃。如果应用使用原生代码，则只能使用公开 NDK API。 应用可通过以下三种方式尝试访问私有平台 API： 应用直接访问私有平台库。应更新应用以添加该应用的库副本，或使用公开 NDK API。 应用使用一个可访问私有平台库的第三方库。即使您确定应用不会直接访问私有库，您仍应针对此情景测试应用。 应用引用一个其 APK 中未包含的库。例如，如果尝试使用自己的 OpenSSL 副本，但忘记将它与应用的 APK 进行捆绑，则可能会出现此情况。正常情况下，此应用可在包含 libcrypto.so 的 Android 平台版本上运行。不过，此应用在不包含此库的新版 Android（例如，Android 6.0 和更高的版本）上会崩溃。为修复此问题，请确保 APK 捆绑您的所有非 NDK 库。 这个问题呢，我们就得依靠别人来解决了，当然，如果有自己的 ndk 使用到了私有库，也是要解决的。 首先，我先检查下，有哪些库中使用了私有库，我们把 targetSdkVersion 改成 23，运行在 7.0的手机上，APP启动后，我们观察日志： 12as a workaround for http://b/26394120, note that the access will be removed in future releases of Android.06-05 16:10:28.556 4284-4284/com.chinahr.android.m W/linker: library &quot;libcrypto.so&quot; (&quot;/vendor/lib/libcrypto.so&quot;) needed or dlopened by &quot;/data/app/com.chinahr.android.m-1/lib/arm/libgmacs.so&quot; is not accessible for the namespace &quot;classloader-namespace&quot; - the access is temporarily granted as a workaround for http://b/26394120, note that the access will be removed in future releases of Android. 发现有两处警告，都是来源于 libgmacs.so 中。联系别的部门做适配… 还有，此问题，如果项目 targetSdkVersion &lt; 24，则会在 7.0手机上每次启动app时，弹出警告框： 但也可以继续正常运行，但是这个很不友好，需要尽快联系提供者解决 其他 7.0 适配的小问题加密方式12345678910111213141516171819202122我们在 logcat 中看到：06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: ********** PLEASE READ ************06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: *06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: * New versions of the Android SDK no longer support the Crypto provider.06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: * If your app was relying on setSeed() to derive keys from strings, you06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: * should switch to using SecretKeySpec to load raw key bytes directly OR06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: * use a real key derivation function (KDF). See advice here :06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: * http://android-developers.blogspot.com/2016/06/security-crypto-provider-deprecated-in.html06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: ***********************************06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: Returning an instance of SecureRandom from the Crypto provider06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: as a temporary measure so that the apps targeting earlier SDKs06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: keep working. Please do not rely on the presence of the Crypto06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: provider in the codebase, as our plan is to delete it06-05 16:10:28.564 4284-4284/com.chinahr.android.m E/System: completely in the future.06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: ********** PLEASE READ ************06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: *06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: * New versions of the Android SDK no longer support the Crypto provider.06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: * If your app was relying on setSeed() to derive keys from strings, you06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: * should switch to using SecretKeySpec to load raw key bytes directly OR06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: * use a real key derivation function (KDF). See advice here :06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: * http://android-developers.blogspot.com/2016/06/security-crypto-provider-deprecated-in.html06-05 16:10:28.566 4284-4284/com.chinahr.android.m E/System: *********************************** 发现 google 对加密方式也有了要求。名为 Crypto 的 JCA 提供程序已弃用，因为它仅有的 SHA1PRNG 算法为弱加密。应用无法再使用 SHA1PRNG（不安全地）派生密钥，因为不再提供此提供程序。而且在未来的版本中，如果继续使用Crypto，将会出错。我们以后需要专注。 通知栏Android 各个版本中，貌似对通知栏都有一定的更改，而且现在也变得很丰富7.0 的通知栏，改变了样式，增加了小图标，还可以显示通知数量。 自己在玩原生7.0 系统时，发现小图标变成灰色的方块了： 然后，发现在 华为 7.0 手机上，小图标显示又是正常的，应该是华为对通知栏显示做了处理 这时候就比较蹩脚了，暂且这么干吧，我们项目中，使用了小米推送（通知消息），查阅了小米推送的文档： * 如果app中同时存在名为mipush_notification和mipush_small_notification的drawable文件，则使用mipush_notification的drawable作为通知的大图标，mipush_small_notification的drawable作为通知的小图标。 * 如果app中只存在其中一个drawable文件，则使用该drawable作为通知的图标。 * 如果app中不存在这两个drawable文件，则使用app的icon作为通知的图标。在MIUI中，通知栏图标统一显示为app的icon，不可以定制。 可以添加个小图标，在推送到达时候显示，透明背景的图片，术语叫：带有alpha 通道的图片。 本来也可以通过 自己控制 NotificationManager 来创建显示，如： 1234567891011NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); Notification notification = builder .setContentTitle(\"这是通知标题\") .setContentText(\"这是通知内容这是通知内容这是通知内容这是通知内容这是通知内容这是通知内容这是通知内容这是通知内容\") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher)// .setColor(Color.parseColor(\"#ff0000”))// 设置小图标背景颜色 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build(); manager.notify(1, notification); 这是我们可以定制的但是现在的项目比较死，暂时不适用自定义的了暂时使用小米推送的改动小图标的方式，替换上一个透明背景的logo吧，总比灰色的方块强吧。而且其他app也是同样的显示效果，如上面的图标中的百度淘宝和头条。有精力的话，使用透传消息，可以自己控制通知栏的样式和显示。 参考： http://iluhcm.com/2017/03/12/experience-of-adapting-to-android-notifications/http://yifeng.studio/2017/05/03/android-7-0-compat-fileprovider/","tags":[{"name":"7.0适配","slug":"7-0适配","permalink":"https://fenglincanyi.github.io/tags/7-0适配/"},{"name":"FileProvider","slug":"FileProvider","permalink":"https://fenglincanyi.github.io/tags/FileProvider/"}]},{"title":"Android 6.0适配","date":"2017-04-12T04:40:00.000Z","path":"2017/04/12/Android 6.0适配/","text":"Android 权限变更在 Android 6.0 之前，APP 的授权是通过在 manifest.xml 文件中，去注册相关权限，安装时就可以获得所有声明了的权限。而在 6.0 及以后的版本，这种在 manifest.xml 声明权限的做法，已经在一些权限上不适用了。在Android 6.0 及以后的系统中，用户可以自动打开或关闭任何应用的权限（设置 -&gt; 应用权限） 权限的划分Android 是基于 Linux 系统的，所以，对于每个文件都有个权限的概念。这次变化，主要将 Android 系统中的权限分为： 正常权限：如很常见的 访问网络； 危险权限：如访问手机状态、位置信息； 特殊权限：如写设置、悬浮窗 另外，还有一个 权限组 的概念： 任何权限都可属于一个权限组，包括正常权限和应用定义的权限所以，每个危险权限都属于不同的权限组中，Google已经定义好了这些归属。 我们主要关注的危险权限和权限组如下： 权限组 权限 CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATECALL_PHONEREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 如果已经申请到了某个组的某一个权限时，那么也同时拥有了该组的其他权限；只要拥有了同类中的一个，那么就拥有了该组的其他权限 大部分的适配工作就是对以上的权限进行预处理，就OK了。 不同版本运行，区别对待 如果你的 targetSdkVersion &lt;= 22，那么安装在 6.0 以上的手机的话，还是以老的授权方式（安装时期）对所有声明了的权限一次性授权。 如果你的 targetSdkVersion &gt; 22，那么安装在 6.0 以上的手机上，不光要在 manifest.xml 中声明，而且有一部分比较危险或者特殊的权限， 需要在 app 运行时期，来提前申请权限。一旦未申请而直接进行操作的话，会直接崩溃SecurityException。 权限处理原则Google 对权限做了进一步要求之后，作为我们开发者，该如何作何权限的适配呢?官方也给出了几个建议： 考虑使用 Intent我们一般可以使用以下 2 种方法，来执行某个任务： 要求提供权限才能执行操作 使用 intent，让其他应用来执行任务 比如：我们要使用拍照的功能，那么我们可以请求 CAMERA 权限，然后可以直接访问相机，控制相机进行拍照；也可以不用申请 CAMERA 权限，我们通过 ACTION_IMAGE_CAPTURE intent 来请求，系统会提示用户选择相机，拍照后返回 onActivityResult()。 类似的：打电话、访问用户的联系人 也是同样的做法 这两种方式各有优缺点：使用权限： 应用可在您执行操作时完全控制用户体验；不过，如此广泛的控制会增加任务的复杂性，因为您需要设计适当的 UI。 系统会在运行或安装应用时各提示用户提供一次权限，应用即可执行操作，不再需要用户进行其他交互。不过，如果用户不授予权限（或稍后撤销权限），应用将根本无法执行操作。 使用 intent: 无需为操作设计 UI。处理 intent 的应用将提供 UI。不过，这意味着您无法控制用户体验。用户可能从未见过的应用交互。 如果用户没有适用于操作的默认应用，则系统会提示用户选择一款应用。如果用户未指定默认处理程序，则他们每次执行此操作时都必须处理一个额外对话框。 仅要求APP所需的权限每次您要求权限时，实际上是在强迫用户作出决定。您应尽量减少提出这些请求的次数。 不要让用户感到无所适从某些情况下，一项或多项权限可能是应用所必需的。在这种情况下，合理的做法是，在应用启动之后立即要求提供这些权限。在这种情况下，合理的做法是，在应用启动之后立即要求提供这些权限。例如，如果您运行摄影应用，应用需要访问设备的相机。在用户首次启动应用时，他们不会对提供相机使用权限的要求感到惊讶。 解释需要权限的原因系统在您调用 requestPermissions() 时显示的权限对话框将说明应用需要的权限，但不会解释为何需要这些权限。某些情况下，用户可能会感到困惑。因此，最好在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。例如，摄影应用可能需要使用位置服务，以便能够为照片添加地理标签。通常，用户可能不了解照片能够包含位置信息，并且对摄影应用想要了解具体位置感到不解。因此在这种情况下，应用最好在调用 requestPermissions() 之前告知用户此功能的相关信息。以上的准则，我们可以参考 微信 或者 头条 进行分析，他们是如何处理好与用户的交互的 6.0 权限适配适配工作我们要对市面上常用的手机进行适配，大部分的手机还是遵守这些规则的。但是对部分小米或魅族系统的权限，厂商还是做了自己的定制的，我们需要花点心思来处理。 普通手机适配一般流程我们分为 3步： checkPermission requestPermission handleResult 如果我们自己实现，就使用 ContextCompat.checkSelfPermission 检查需要的权限；如果不是被授权，则我们需要请求这个权限 ActivityCompat.requestPermissions，可以同时请求一个或多个权限；然后我们重写 Activity 的 onRequestPermissionsResult() 方法，根据用户授权结果，进行相应的结果处理。 不再造轮子了，我项目中了 RxPermission 开源库，并借鉴了EasyPermission，AndPermission 的思路。代码层面不再展开，实现比较容易。。。 处理流程： 我们再来看看 微信 的流程，在第一次安装，启动后，就会要求3个比较重要的权限，一个一个来请求获取，如果一旦有未同意的，就不让进入。这种做法也是比较合理的，这些权限都没同意，后续的操作没法正常进行。 小米、魅族适配适配最头痛的就是 这种 爱搞特殊的手机了，没办法，手机碎片化的问题只能盼着慢慢消磨了。 小米、魅族手机的话，会出现 checkPermission 时，返回true，但是我们使用的时候实际是 关闭权限的；这时候，我们就不能只 check了，还要 使用 AppOpsManager 来获取相关的操作，看这个操作是否有执行的权限。通过这样双重的检查权限，都通过了，才可以执行操作。 1234567891011121314151617181920212223242526public static boolean hasPermission(@NonNull Context context, @NonNull List&lt;String&gt; permissions) &#123; if(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) &#123; return true; &#125; else &#123; for (Object permission : permissions) &#123; // 获取app中 权限关联的操作 String op = AppOpsManagerCompat.permissionToOp(permission.toString()); if (!TextUtils.isEmpty(op)) &#123; // 查看 操作 是否被允许 int result = AppOpsManagerCompat.noteProxyOp(context, op, context.getPackageName()); if (result == MODE_IGNORED) &#123; return false; &#125; // 再次检查，确保有权限 result = ContextCompat.checkSelfPermission(context, permission.toString()); if (result != PERMISSION_GRANTED) &#123; return false; &#125; &#125; &#125; return true; &#125; &#125; 在小米论坛上，已经有人提到这个问题，解决方法就是再次使用 AppOpsManager 来检查。http://www.miui.com/thread-4498742-1-1.html 总结 Android 安全架构的中心设计点是：在默认情况下任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作 可以使用 intent 启动的操作，尽量还是使用intent吧，申请权限毕竟是要弹框阻碍用户操作的，而且如果没同意，还要做相应的操作来配合。 参考： https://developer.android.com/guide/topics/permissions/normal-permissions.html?hl=zh-cnhttps://developer.android.com/training/permissions/best-practices.html?hl=zh-cn#perms-vs-intentshttps://mp.weixin.qq.com/s?__biz=MzIxNzEyMzIzOA==&amp;mid=2652313851&amp;idx=1&amp;sn=a15519b65e7bedefbb566fe6d01935cb&amp;scene=4#wechat_redirect","tags":[{"name":"6.0适配","slug":"6-0适配","permalink":"https://fenglincanyi.github.io/tags/6-0适配/"},{"name":"运行时权限","slug":"运行时权限","permalink":"https://fenglincanyi.github.io/tags/运行时权限/"}]},{"title":"Android 增量编译方案总结","date":"2017-03-18T12:10:00.000Z","path":"2017/03/18/Android 增量编译方案总结/","text":"自从去年10月份，使用Freeline 感觉非常不错，开发效率提升数倍。由于工作原因，一直将这篇总结拖到现在。ok，现在好好总结下。。。 前言：Android 开发者之痛普通的编译流程： 存在问题： 存在问题： 全量编译 没有缓存机制 单流程构建流程 代码和资源越来越多，项目编译越来越慢 现状： Windows: 3.5min Mac: 2.5min 提高机器硬件已不能解决开发耗时严重的问题了… 如何解决？ 配置Gradle 参数、调整tasks间执行顺序、依赖 可否实现增量编译 组件化，独立module开发、维护 探索之路Buck—— Facebook 并发编译，建立多个并发子任务依赖关系，有向拓扑图，通过多线程并发把各个子节点构建出来，充分利用多核优势 BUCK建立了一套完善的依赖规则以及细化的缓存系统来缩减编译时间 增量构建的方式：以工程目录为单位进行增量构建，发生变更时候，变更的工程，以及该工程作为父节点或祖先节点的工程，均需要重新构建，构建完这些变更涉及的工程后，Buck需要重新走一次合并各工程DEX,对齐，签名，打包APK的过程,构建完毕后，继续走安装流程 缺点： 增量机制并不完善 引入工程量大，入侵性强 Windows平台不支持 后传：OKBuck OkBuck 的目标，是通过读取工程的 Gradle 配置，自动生成 BUCK 脚本，免去开发者下载依赖的 jar/aar 文件，编写、维护 BUCK 脚本、处理依赖之间的冲突等繁琐又容易出错的工作。 LayoutCast——屠毅敏（AndroidDynamicLoader ） 资源文件更改： 代码变动： 编译速度对比： 原理实现： 利用反射，将修改的patch dex 插入到 dex Elements[] 最前面 资源修改：通过运行时反射,拿到 R.class 字段，得出 ids.xml 和 pubilc.xml（ids: 我们定义的 view 的 id，public：包含ids的信息，及layout、drawable、color、string、dimen、style、attr） 1234567891011121314151617181920212223242526272829303132public class ArtUtils &#123; public static boolean overrideClassLoader(ClassLoader cl, File dex, File opt) &#123; try &#123; ClassLoader bootstrap = cl.getParent(); Field fPathList = BaseDexClassLoader.class.getDeclaredField(\"pathList\"); fPathList.setAccessible(true); Object pathList = fPathList.get(cl); Class cDexPathList = bootstrap.loadClass(\"dalvik.system.DexPathList\"); Field fDexElements = cDexPathList.getDeclaredField(\"dexElements\"); fDexElements.setAccessible(true); Object dexElements = fDexElements.get(pathList); DexClassLoader cl2 = new DexClassLoader(dex.getAbsolutePath(), opt.getAbsolutePath(), null, bootstrap); Object pathList2 = fPathList.get(cl2); Object dexElements2 = fDexElements.get(pathList2); Object element2 = Array.get(dexElements2, 0); int n = Array.getLength(dexElements) + 1; Object newDexElements = Array.newInstance(fDexElements.getType().getComponentType(), n); Array.set(newDexElements, 0, element2); // 插入到数组最前面 for (int i = 0; i &lt; n - 1; i++) &#123; Object element = Array.get(dexElements, i); Array.set(newDexElements, i + 1, element); // 其余 dex 元素依次后移 &#125; fDexElements.set(pathList, newDexElements); return true; &#125; catch (Exception e) &#123; Log.e(\"lcast\", \"fail to override classloader \" + cl + \" with \" + dex, e); return false; &#125; &#125;&#125; 缺点： 当前的修改，会把之前的修改一起带进来，一起增量，修改次数多时，速度也会越来越慢（只是针对第一次build后的基线包做的增量修改，修改多次会带上很多的增量文件） 资源修改是利用反射，项目中资源越来越多时，速度提升并不明显 不支持Android 5.0以下的设备 Instant-Run原理实现 第一次编译时，在transform 时通过ASM对每一个方法加入 局部变量 change，更改代码后，会将 更改的类 加上 $override ，将最新类 push 到 手机上。就是通过 hack method 的方式来实现动态代码替换的 资源的修改更新，通过反射的方式，生成一个 AssetManager，调用 相关外界加载 资源的方法，将最新的资源包加载进来（全量的包），然后修剪删除缓存，刷新UI使之生效 缺点： 资源文件仍然是一个全量的过程，资源文件越大，速度并没有明显提升 无法debug，因为是 方法的hack，无法追到 堆栈信息 只支持Android5.0以上 JRebel for Androidhttps://zeroturnaround.com/software/jrebel-for-android/features/ 缺点 收费 Crash 后需要重新全量编译，第一次编译很慢，亲测结果 神器Freeline——集百家之长简介 Freeline是蚂蚁金服旗下一站式理财平台蚂蚁聚宝团队在Android平台上的量身定做的一个基于动态替换的编译方案 Freeline 借鉴了layoutCast、buck, instant run 的思想和方法，在其他增量编译方案上做了各种优化和性能的提升 Freeline 整体工作流程 PC端与手机建立TCP长连接 扫描各个子工程文件变化 各个子工程的增量dex构建、增量资源包构建 合并所有工程dex 传输增量包 App 更新代码或资源，刷新或重启 单个工程流程 几个重要的模块Python 实现任务调度（调度中心、发号施令）build_commands.py builder.py各种命令, 各种构建 freeline_build.py gradle_clean_build.py gradle_inc_build.pytask拓扑序列构建, task_engine.py任务并发执行，依赖的模块在进行构建时，当前task.wait()，当其依赖执行结束，再执行此task android_tools.py建立连接、安装apk、一些辅助类 gradle_tools.pyGradle执行的辅助类，扫描各个文件(GradleScanChangedFilesCommand)、资源，是否有变化、存储信息 sync_client.py将代码、资源同步到手机 Gradle-Plugin 负责构建任务、代码注入等注意：对于低版本的gradle插件，则不能使用 transform 时来进行字节码修改，要通过 preDex 这个 task 进行字节码的修改 12345if (!it.moduleVersion.startsWith(\"1.5\") &amp;&amp; !it.moduleVersion.startsWith(\"2\")) &#123; isLowerVersion = true return false&#125; Freeline-runtime 主要处理 设备连接，增量代码、资源的更新具体参考源码查看，此处不再贴 代码增量实现使用 Qzone 的思路进行实现：DexUtils: 分别对 4.0 以上和以下的做兼容，具体看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546try &#123; Object newDexElements; int dexLength; if (VERSION.SDK_INT &gt;= 14) &#123; pathListField = ReflectUtil.fieldGetOrg(classLoader, Class.forName(\"dalvik.system.BaseDexClassLoader\"), \"pathList\"); fDexElements = ReflectUtil.fieldGetOrg(pathListField.get(classLoader), \"dexElements\"); Object e = fDexElements.get(pathListField.get(classLoader)); dstObject = e; dexFiles = new DexFile[Array.getLength(e)]; for (int i = 0; i &lt; Array.getLength(e); ++i) &#123; newDexElements = Array.get(e, i); dexFiles[i] = (DexFile) ReflectUtil.fieldGet(newDexElements, \"dexFile\"); &#125; &#125; else &#123; pathListField = ReflectUtil.fieldGetOrg(classLoader, \"mDexs\"); dstObject = pathListField.get(classLoader); dexFiles = new DexFile[Array.getLength(dstObject)]; for (dexLength = 0; dexLength &lt; Array.getLength(dstObject); ++dexLength) &#123; dexFiles[dexLength] = (DexFile) Array.get(dstObject, dexLength); &#125; &#125; dexLength = Array.getLength(dstObject) + 1; newDexElements = Array.newInstance(fDexElements.getType().getComponentType(), dexLength); DexClassLoader dynamicDex = new DexClassLoader(dex.getAbsolutePath(), opt.getAbsolutePath(), null, classLoader.getParent()); Log.i(TAG, \"after opt, dex len:\" + dex.length() + \"; opt len:\" + opt.length()); Object pathList = pathListField.get(dynamicDex); Object dexElements = fDexElements.get(pathList); Object firstDexElement = Array.get(dexElements, 0); Array.set(newDexElements, 0, firstDexElement); for (int i = 0; i &lt; dexLength - 1; ++i) &#123; Object element = Array.get(dstObject, i); Array.set(newDexElements, i + 1, element); &#125; if (VERSION.SDK_INT &gt;= 14) &#123; fDexElements.set(pathListField.get(classLoader), newDexElements); &#125; else &#123; pathListField.set(classLoader, newDexElements); &#125; return true;&#125; catch (Exception e) &#123; Log.e(TAG, \"fail to override classloader \" + classLoader + \" with \" + dex.getAbsolutePath(), e); return false;&#125; Preverify 过程：dex2opt过程中，若发现当前类中，存在一个直接引用类也和当前类在同一个dex中，则当前类会被打上 verified=true 的标记。下次加载时，则会判断这个类所在的dex是否是同一个dex 如何避免 preverify 异常？在 dexopt 过程中，Class_isPreverfied 问题：通过在每个类的构造方式，加入一个 另一个dex的 类，让其preverify 失效，这样就可以让增量的class被加载了这也是Google的一个安全策略 相关知识可参考：直接引用类的定义：https://zhuanlan.zhihu.com/p/20308548dex分包过程，dexopt介绍：https://segmentfault.com/a/1190000004053072 资源的更新逻辑根据最新的 R.java 文件 拿到 各个资源id 生成 public.xml 和 ids.xml，用于解决资源id 冲突 id-gen-tool 工具 对于增量的 资源进行 Freelineaapt 编译，未做过更改的资源，直接使用 backup 中的资源，再打成一个 增量包：inc.pack 增量包中，只包含 增量的资源，全量的arsc 和 AndroidManifest.xml Resources.arsc 并不一定会打进 pack 中，只有 资源的更改引起 arsc 变化时，才打入包中，arsc 的体积也是占一定比例的 手机端，资源更新生效： 通过借鉴 instant run的方式，找到 resDir 的路径，将pack解压覆盖至该目录，然后 pruneResourceCaches,刷新UI Freeline 使用及相关问题不再浪费篇幅，直接贴出我总结的内容： https://github.com/fenglincanyi/Study/blob/master/Freeline%E7%9B%B8%E5%85%B3/Freeline_use.md 实例分析 我们重点关注 项目目录下的 app/build/freeline 更改代码后，再执行增量编译后，观察此目录： 只生成了最新的更改过的文件反编译 dex 目录下的 classes.dex 得出, 此文件里全是更改过的类文件： 换个目录看看： 对 hackload.dex 反编译： 发现这个 hackload.dex 就是插桩时候，使用的单独的dex，里面是用来避免 preverify 问题的类随后，我们看看编译后的apk 文件，解压缩，反编译看看任意一个classes.dex: 发现，确实是在构造方法里插入一个其他dex中的类，来避免打上 verified 的标识，验证了上面的做法。好，松一口气，代码更新算是说完了… 下面，我们看看资源是怎么更新的… 前面说过：是通过反向对 R.java 文件摘出 资源 id信息，放在 ids.xml 和 public.xml 中，那我们来看看这两个文件： ids.xml: 里面是压缩过的id信息，就是我们在写布局文件的那些内容 public.xml: 此处只是部分，public.xml 文件记录了 name 和 id 之间的映射 一个普通的 R.java 文件，包含了以下资源信息 所以，这里的 ids.xml 只存储了 我们自己写的 id 信息，而 public.xml 存储了 R.java 完整信息。ids.xml 是为了处理资源id冲突问题，预先准备的文件 再来看看 增量资源相关的： app.pack 文件压缩了所有的资源文件，包括assets 和 res 目录下的资源文件，和清单文件，资源索引表 解压 app.pack 文件后： 扩展一下，看看 resource.arsc 文件：此文件的并不是APP一下子解析加载的，是按需加载，它是一种二进制索引表,对应了app里所有资源name,及id 总结 整个 Freeline 项目的源码很值得研究，里面有好多的实现思路和解决方法都是精益求精的。把增量和优化做到极致。 充分的借鉴了 layoucast 的代码更新思路，Buck 的并发构建、有向拓扑的规则、instant run的字节码修改、monkeyPatcher的实现方法，另外借助 gradle transform 插件及 preDex task时机进行字节码修改，真的是集百家之长。工作启示： 解决方法永远会有更优的，只是你暂时没找到 复杂的工程都是一点一点做出来的 部分源码注释阅读 freeline 的 python模块代码的注释：https://github.com/fenglincanyi/Study/tree/master/Freeline%E7%9B%B8%E5%85%B3/freeline%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/freeline/freeline/freeline 补充点想说的太多了，自己写个配注。。。 Gradle plugin 模块：负责构建时，做的一些逻辑如：项目描述文件（FreelineInitializer.groovy 执行初始化时，生成项目描述文件） reelineInjector.groovy 里的 hackClass -&gt; new FreelineClassVisitor -&gt; 进行字节码的注入这个思路借鉴了instant run的做法 Freeline-runtime/DexUtils处理dex增量包的逻辑 Instant-run-serve 项目下的 monkeyPatcher 被Freeline直接复用了 Gradle transform plugintransform 是在java文件编译成class之后，合成dex之前，此期间执行的，来修改class内容 transform 解释：http://blog.csdn.net/sbsujjbcy/article/details/50839263源码位置：https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/build-system/gradle-core/ instant run 中涉及到的类：用到了ASMIncrementalChangeVisitor.javaIncrementalSupportVisitor.javaIncrementalVisitor.java 使用到，调用 task 命令，传入参数：1command += ' -P freelineBuild=true' # 使用 gradle 方式，加入了freelineBuild 属性 ，在 FreelinePlugin.groovy 中有体现","tags":[{"name":"Freeline","slug":"Freeline","permalink":"https://fenglincanyi.github.io/tags/Freeline/"}]},{"title":"Weex SDK源码分析（二）","date":"2017-02-28T11:32:00.000Z","path":"2017/02/28/Weex SDK源码分析（二）/","text":"Weex 渲染页面过程 weex 渲染入口 render()渲染过程从 WXSDKInstance.render() 开始追溯，render()方法是异步执行渲染工作的。render()重载的方法比较多，此处介绍最基础的一个。参数代表的含义： pageName：用于查看日志，渲染的哪个页面作为标识 template：加载的本地的或远程的 js（we文件被weex transform后的 js） options：配置信息，包括系统版本、app版本、设备信息等 jsonInitData：用于渲染的初始数据 flag：监听渲染的时机： APPEND_ASYNC：渲染完第一个view后，IWXRenderListener.onViewCreated()调用 APPEND_ONCE：渲染完整个view tree后，onViewCreated()调用 12345678wxSDKInstance.render( getPageName(), template, options, jsonInitData, ScreenUtil.getDisplayWidth(this), ScreenUtil.getDisplayHeight(this), WXRenderStrategy.APPEND_ASYNC); 接着，渲染工作真正开始于 renderInternal()： 123456789private void ensureRenderArchor()&#123; if(mRenderContainer == null)&#123; mRenderContainer = new RenderContainer(getContext()); mRenderContainer.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); mRenderContainer.setBackgroundColor(Color.TRANSPARENT); mRenderContainer.setSDKInstance(this); mRenderContainer.addOnLayoutChangeListener(this); &#125; &#125; 会进行 mRenderContainer 的初始化，RenderContainer 是一个 weex 扩展的 FrameLayout，后期操作，会在这个 container 中添加view元素。我们接着看 render 过程，WXSDKManager.createInstance() 创建实例： 1234void createInstance(WXSDKInstance instance, String code, Map&lt;String, Object&gt; options, String jsonInitData) &#123; mWXRenderManager.registerInstance(instance); mBridgeManager.createInstance(instance.getInstanceId(), code, options, jsonInitData); &#125; 此过程中，WXRenderManager 注册实例，实际就是在 mRegistries（map）中存储该实例的信息，并且创建 renderStatement。mBridgeManager 创建实例时，WXModuleManager 会创建 DomModule，由WXDomManager进行创建，sDomModuleMap 存储该 wxSDKInstance 的WXDomModule。然后，异步执行 invokeCreateInstance()，此过程还会执行 initFramework() 操作。initFramework() 后，会创建出一个 WXJSObject 将 wxsdkinstance相关的数据存储，组成一个数组的形式，传给执行 js 的方法： 123456789101112WXJSObject instanceIdObj = new WXJSObject(WXJSObject.String, instance.getInstanceId()); WXJSObject instanceObj = new WXJSObject(WXJSObject.String, template); WXJSObject optionsObj = new WXJSObject(WXJSObject.JSON, options == null ? \"&#123;&#125;\" : WXJsonUtils.fromObjectToJSONString(options)); WXJSObject dataObj = new WXJSObject(WXJSObject.JSON, data == null ? \"&#123;&#125;\" : data); WXJSObject[] args = &#123;instanceIdObj, instanceObj, optionsObj, dataObj&#125;; invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args,false); 然后，WXBridgeManager 会调用 mWXBridge.execJS() 去调用底层的 C++方法，执行js。 底层C++ 调用Weex Android 功能我们再来看看 c++ 代码实现的功能，以 callNative() 为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * This Function is a built-in function that JS bundle can execute * to call native module. */v8::Handle&lt;v8::Value&gt; callNative(const v8::Arguments &amp;args) &#123; JNIEnv *env = getJNIEnv(); //instacneID args[0] jstring jInstanceId = NULL; if (!args[0].IsEmpty()) &#123; v8::String::Utf8Value instanceId(args[0]); jInstanceId = env-&gt;NewStringUTF(*instanceId); &#125; //task args[1] jbyteArray jTaskString = NULL; if (!args[1].IsEmpty() &amp;&amp; args[1]-&gt;IsObject()) &#123; v8::Handle&lt;v8::Value&gt; obj[1]; v8::Handle&lt;v8::Object&gt; global = V8context-&gt;Global(); json = v8::Handle&lt;v8::Object&gt;::Cast(global-&gt;Get(v8::String::New(\"JSON\"))); json_stringify = v8::Handle&lt;v8::Function&gt;::Cast(json-&gt;Get(v8::String::New(\"stringify\"))); obj[0] = args[1]; v8::Handle&lt;v8::Value&gt; ret = json_stringify-&gt;Call(json, 1, obj); v8::String::Utf8Value str(ret); int strLen = strlen(ToCString(str)); jTaskString = env-&gt;NewByteArray(strLen); env-&gt;SetByteArrayRegion(jTaskString, 0, strLen, reinterpret_cast&lt;const jbyte *&gt;(ToCString(str))); // jTaskString = env-&gt;NewStringUTF(ToCString(str)); &#125; else if (!args[1].IsEmpty() &amp;&amp; args[1]-&gt;IsString()) &#123; v8::String::Utf8Value tasks(args[1]); int strLen = strlen(*tasks); jTaskString = env-&gt;NewByteArray(strLen); env-&gt;SetByteArrayRegion(jTaskString, 0, strLen, reinterpret_cast&lt;const jbyte *&gt;(*tasks)); // jTaskString = env-&gt;NewStringUTF(*tasks); &#125; //callback args[2] jstring jCallback = NULL; if (!args[2].IsEmpty()) &#123; v8::String::Utf8Value callback(args[2]); jCallback = env-&gt;NewStringUTF(*callback); &#125; if (jCallNativeMethodId == NULL) &#123; // 反射方式，拿到 weexsdk 的callNative方法的ID jCallNativeMethodId = env-&gt;GetMethodID(jBridgeClazz, \"callNative\", \"(Ljava/lang/String;[BLjava/lang/String;)I\"); &#125; // 调用 java 的 callNative 方法 int flag = env-&gt;CallIntMethod(jThis, jCallNativeMethodId, jInstanceId, jTaskString, jCallback); if (flag == -1) &#123; LOGE(\"instance destroy JFM must stop callNative\"); &#125; env-&gt;DeleteLocalRef(jTaskString); env-&gt;DeleteLocalRef(jInstanceId); env-&gt;DeleteLocalRef(jCallback); return v8::Integer::New(flag);&#125; C++ 解析 js 代码后，返回来再调用 weex sdk 的 Android 代码，通过 JNI 提供的反射方式拿到方法的 id，并调用执行。相对应的，我们找到 Android callNative() 代码： 123456789101112131415161718192021222324252627public int callNative(String instanceId, String tasks, String callback) &#123; long start = System.currentTimeMillis(); WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(instanceId); if(instance != null) &#123; instance.firstScreenCreateInstanceTime(start); &#125; int errorCode = IWXBridge.INSTANCE_RENDERING; try &#123; // 通过 WXBridgeManager.callNative 进行 tasks 的分发执行 errorCode = WXBridgeManager.getInstance().callNative(instanceId, tasks, callback); &#125;catch (Throwable e)&#123; //catch everything during call native. if(WXEnvironment.isApkDebugable())&#123; WXLogUtils.e(TAG,\"callNative throw exception:\"+e.getMessage()); &#125; &#125; if(instance != null) &#123; instance.callNativeTime(System.currentTimeMillis() - start); &#125; if(WXEnvironment.isApkDebugable())&#123; if(errorCode == IWXBridge.DESTROY_INSTANCE)&#123; WXLogUtils.w(\"destroyInstance :\"+instanceId+\" JSF must stop callNative\"); &#125; &#125; return errorCode; &#125; Weex native 响应 C++ 的调用WXBridgeManager.callNative() 对 tasks 进行分发，我们来看看如何分发的： 123456789101112131415161718192021222324252627282930313233JSONArray array = JSON.parseArray(tasks);... ...int size = array.size(); if (size &gt; 0) &#123; try &#123; JSONObject task; for (int i = 0; i &lt; size; ++i) &#123; task = (JSONObject) array.get(i); if (task != null &amp;&amp; WXSDKManager.getInstance().getSDKInstance(instanceId) != null) &#123; Object target = task.get(MODULE); if(target != null)&#123; if(WXDomModule.WXDOM.equals(target))&#123; WXDomModule dom = getDomModule(instanceId); dom.callDomMethod(task); &#125;else &#123; WXModuleManager.callModuleMethod(instanceId, (String) target, (String) task.get(METHOD), (JSONArray) task.get(ARGS)); &#125; &#125;else if(task.get(COMPONENT) != null)&#123; //call component WXDomModule dom = getDomModule(instanceId); dom.invokeMethod((String) task.get(REF),(String) task.get(METHOD),(JSONArray) task.get(ARGS)); &#125;else&#123; throw new IllegalArgumentException(\"unknown callNative\"); &#125; &#125; &#125; &#125; catch (Exception e) &#123; WXLogUtils.e(\"[WXBridgeManager] callNative exception: \", e); commitJSBridgeAlarmMonitor(instanceId, WXErrorCode.WX_ERR_INVOKE_NATIVE,\"[WXBridgeManager] callNative exception \"+e.getCause()); &#125; &#125; ... ... 分发规则，对 tasks 逐个分类处理： 如果是 module: 如果 是 dom：执行 WXDomModule.callDomMethod()； 如果 不是 dom (普通的WXModule) : 执行WXModuleManager.callModuleMethod() 如果是 component： 调用 WXDomModule.invokeMethod() task 数据格式（json），如图： 这里只分析第一种情况（其他相似）：WXDomModule.callDomMethod()：会根据 task 的 method 属性分类处理，此处只分析一个：CREATE_BODY：会继续调用 createBody() 方法，将 wxSDKInstance.id 和 task的args 信息发送给WXDomHandler。WXDomHandler 的 handleMessage() 中也有很多分类处理，对于WX_DOM_CREATE_BODY：会执行：1mWXDomManager.createBody(task.instanceId, (JSONObject) task.args.get(0)); 具体可参考 WXDomModule、WXDomHandler 类分析这个时候，就回到我们之前说过的 WXDomStatement 的流程了，WXDomStatement会添加dom 节点（addDomInternal() ），在 addDomInternal 过程中，对dom节点又是一通猛烈的操作：根节点（root节点的准备工作），普通节点（add到父节点下）。然后，对 dom 对象 进行遍历操作（递归）：domObject.traverseTree()，在dom 线程创建 component，生成 component 树（也是递归操作：通过WXRenderStatement.generateComponentTree() ）。对于每个dom节点都会进行 setLayout()、setExtra()、setPadding()，可以去看看compent.setLayout()，就是去使用Android的API 对view进布局和绘制，此处不再贴代码。 总结 WXBridge 是 Android 与 底层 C++ 的衔接处，Android &lt;=&gt; C++ 的交互，及方法接口都在此类中，的确起到了见名知义的效果 Weex Android SDK 是使用 Android的API（Java层），实现了view的布局、绘制。并不是依靠 底层so包实现，与IOS的sdk实现方式不同（听同事说……） component 处置 weex 的view绘制、布局过程，和Android native处理view的流程十分相似，具体可以参考后面的链接（阿里大神也分析过） 参考：http://www.jianshu.com/p/3160a0297345","tags":[{"name":"Weex","slug":"Weex","permalink":"https://fenglincanyi.github.io/tags/Weex/"},{"name":"Android","slug":"Android","permalink":"https://fenglincanyi.github.io/tags/Android/"}]},{"title":"Weex SDK源码分析（一）","date":"2017-02-28T07:06:00.000Z","path":"2017/02/28/Weex SDK源码分析（一）/","text":"WeexSDK 初始化源码分析 整个Weex SDK 初始化过程，入口是WXSDKEngine.initialize()，方法主要是依靠 doInitInternal() 方法执行初始化操作。里面涉及了WXEnvironment 相关环境的设置，几个重要的Manager的初始化操作，包括WXBridgeManager、WXSDKManager、WXRenderManager、WXDomManager，前两个 manager 以单例形式呈现的。初始化完相关管理类，后面进行 component、module的注册。 下面对这一过程，进行一一分析： WXSDKEngine.doInitInternal() 方法：12345678910111213141516171819202122232425262728private static void doInitInternal(final Application application, final InitConfig config) &#123; WXEnvironment.sApplication = application; WXEnvironment.JsFrameworkInit = false; WXBridgeManager.getInstance().post(new Runnable() &#123; @Override public void run() &#123; long start = System.currentTimeMillis(); WXSDKManager sm = WXSDKManager.getInstance(); if (config != null) &#123; sm.setInitConfig(config); if (config.getDebugAdapter() != null) &#123; config.getDebugAdapter().initDebug(application);// 关于weex debug操作，不是此篇关注的重点，略过 &#125; &#125; WXSoInstallMgrSdk.init(application); boolean isSoInitSuccess = WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config != null ? config.getUtAdapter() : null); if (!isSoInitSuccess) &#123; return; &#125; sm.initScriptsFramework(config != null ? config.getFramework() : null); WXEnvironment.sSDKInitExecuteTime = System.currentTimeMillis() - start; WXLogUtils.renderPerformanceLog(\"SDKInitExecuteTime\", WXEnvironment.sSDKInitExecuteTime); &#125; &#125;); register(); &#125; WXSDKManager的初始化首先，是WXSDKManager的初始化，会将WXRenderManager、WXDomManager初始化，并拿到WXBridgeManager实例的引用。 关于 WXRenderManager管理渲染操作，主要操作管理的是WXRenderStatement对象（WXRenderManager 也并不是一个线程安全的类，涉及到UI的更新操作。后面会对WXRenderStatement 进行分析）WXRenderManager 主要的2个成员：mRegistries 和 mWXRenderHandler：12private ConcurrentHashMap&lt;String, WXRenderStatement&gt; mRegistries;private WXRenderHandler mWXRenderHandler; mRegistries存储WXRenderStatement，以 WXSDKInstance.id 为key存储WXRenderStatement，所以一个WXSDKInstance对应一个WXRenderStatement。WXRenderManager 的 createBody、addComponent等等操作都是针对某个WXSDKInstance的 statement 调用操作的。具体的渲染，WXRenderStatement负责完成。mWXRenderHandler 是将外界传给它的 渲染相关的task 发送消息，然后主线程收到messge后，进行相关渲染操作。 关于 WXDomManager管理dom操作，作为客户端执行dom命令，会调用 WXDomStatement 创建命令执行相对应的操作。里面提供的方法通常是在 dom 线程中调用。其中有：12345private WXThread mDomThread; /** package **/ Handler mDomHandler; private WXRenderManager mWXRenderManager; private ConcurrentHashMap&lt;String, WXDomStatement&gt; mDomRegistries; mDomRegistries 和上面类似，大家一看就懂，。mWXRenderManager 是拿到上一步初始化好的 mWXRenderManager实例。mDomThread是WXDomManager创建的一个thread，也是WXThread，其中的handler是WXDomHandlermDomHandler 是这个mDomThread的handler引用。WXDomHandler 是关于dom操作的一个类，实现了Handler.Callback接口，会将mDomHandler发送的dom消息分类处理，这一任务是交给了 WXDomManager： 12345678910111213141516171819202122232425262728293031323334@Overridepublic boolean handleMessage(Message msg) &#123; if (msg == null) &#123; return false; &#125; int what = msg.what; Object obj = msg.obj; WXDomTask task = null; if (obj instanceof WXDomTask) &#123; task = (WXDomTask) obj; &#125; if (!mHasBatch) &#123; mHasBatch = true; mWXDomManager.sendEmptyMessageDelayed(WXDomHandler.MsgType.WX_DOM_BATCH, DELAY_TIME); &#125; switch (what) &#123; case MsgType.WX_DOM_CREATE_BODY: mWXDomManager.createBody(task.instanceId, (JSONObject) task.args.get(0)); break; case MsgType.WX_DOM_UPDATE_ATTRS: mWXDomManager.updateAttrs(task.instanceId, (String) task.args.get(0), (JSONObject) task.args.get(1)); break; case MsgType.WX_DOM_UPDATE_STYLE: mWXDomManager.updateStyle( task.instanceId, (String) task.args.get(0), (JSONObject) task.args.get(1), task.args.size() &gt; 2 &amp;&amp; (boolean) task.args.get(2) ); break; case ... case ... 具体的manager操作，会交给对应的 domstatement 操作，上面已经说过。 WXSoInstallMgrSdk 是管理 so 相关操作和cpu平台的支持情况。WXSoInstallMgrSdk.initSo() 执行 weexv8.so 包的加载，就和普通加载so包的方式一样（System.loadLibrary(libName) ）。 这里注意：weex 的 so 包不支持 mips平台的 如果so包加载失败，则初始化操作会就此结束，后续工作不再执行。so包加载完成之后，WXSDKManager会调用WXBridgeManager执行 js Framework的初始化，并发送消息给WXBridgeManager，WXBridgeManager调用自己的 handleMessage() 处理操作，下面会有分析。 WXBridgeManager 的初始化其次，WXBridgeManager 的初始化。会创建名为：WeexJSBridgeThread的 WXThread，WXThread是一个weex封装的HandlerThread。为了方便该线程的消息处理，具体细节可参考源码查看。WXBridgeManager 自己也实现了 Handler.Callback 接口，用于处理消息，接受消息后对 js framework 的初始化操作进行控制。 发送消息： 1234567891011/** * Initialize JavaScript framework * @param framework String representation of the framework to be init. */public synchronized void initScriptsFramework(String framework) &#123; Message msg = mJSHandler.obtainMessage(); msg.obj = framework; msg.what = WXJSBridgeMsgType.INIT_FRAMEWORK; msg.setTarget(mJSHandler); msg.sendToTarget();&#125; 接收消息： 123456789101112131415@Overridepublic boolean handleMessage(Message msg) &#123; if (msg == null) &#123; return false; &#125; int what = msg.what; switch (what) &#123; case WXJSBridgeMsgType.INIT_FRAMEWORK: invokeInitFramework(msg);// 过程中会加载 main.js，调用c++ 进行Framework的初始化：mWXBridge.initFramework(framework, assembleDefaultOptions()) break; case WXJSBridgeMsgType.CALL_JS_BATCH: invokeCallJSBatch(msg); break; case ... 在 WXBridge 中，是调用 底层native的方法： 123456/** * Init JSFrameWork * * @param framework assets/main.js */public native int initFramework(String framework, WXParams params); 底层 C++代码中： 123jint Java_com_taobao_weex_bridge_WXBridge_initFramework(JNIEnv *env, jobject object, jstring script, jobject params) js framework 初始化就交给 C++ 来处理了 在这里再多看一眼：在so包加载后，C++层第一步就会把 WXBridge 加载出来，作为2层之间的桥梁： 1234567891011121314151617181920/** * This function will be call when the library first be load. * You can do some init in the lib. return which version jni it support. */jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; LOGD(\"begin JNI_OnLoad\"); JNIEnv *env; /* Get environment */ if ((vm)-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; return JNI_FALSE; &#125; sVm = vm; jclass tempClass = env-&gt;FindClass( \"com/taobao/weex/bridge/WXBridge\"); jBridgeClazz = (jclass) env-&gt;NewGlobalRef(tempClass); env-&gt;DeleteLocalRef(tempClass); LOGD(\"end JNI_OnLoad\"); return JNI_VERSION_1_4;&#125; 注册操作weex 内置的 component 和 module 都会在此过程中注册，这一过程还包含了dom的注册操作。注册操作，会由registerModules来进行操作：registerModules()，registerComponents()，这两个都是异步执行，最终调用： 12345678// modules the format is like &#123;'dom':['updateAttrs','updateStyle'],'event':['openUrl']&#125;WXJSObject[] args = &#123;new WXJSObject(WXJSObject.JSON, WXJsonUtils.fromObjectToJSONString(modules))&#125;;mWXBridge.execJS(\"\", null, METHOD_REGISTER_MODULES, args);WXJSObject[] args = &#123;new WXJSObject(WXJSObject.JSON, WXJsonUtils.fromObjectToJSONString(components))&#125;;mWXBridge.execJS(\"\", null, METHOD_REGISTER_COMPONENTS, args); execJS() 最终是调用WXBridge.execJS() 的native方法，交给底层c++来执行： 123jint Java_com_taobao_weex_bridge_WXBridge_execJS(JNIEnv *env, jobject this1, jstring jinstanceid, jstring jnamespace, jstring jfunction, jobjectArray jargs) C++ 使用反射的方式，找到WXJSObject类，找到相关的属性和方法， 1jclass jsObjectClazz = env-&gt;FindClass(\"com/taobao/weex/bridge/WXJSObject\"); 调用 js Framework的相关api 执行。 源码：https://github.com/apache/incubator-weex/tree/master/android/sdkhttps://github.com/alibaba/weex_v8core","tags":[{"name":"Weex","slug":"Weex","permalink":"https://fenglincanyi.github.io/tags/Weex/"},{"name":"Android","slug":"Android","permalink":"https://fenglincanyi.github.io/tags/Android/"}]},{"title":"Gradle实现自动拉取git及压缩文件","date":"2017-02-01T07:00:00.000Z","path":"2017/02/01/Gradle实现自动拉取git及压缩文件/","text":"问题在实现 hybird 相关开发时，h5文件需要不断重新拉取，并解压文件，拷贝至项目的相关目录下。手工完成比较繁琐且耗时。自己查阅 gradle 相关文档，将其过程实现脚本自动化。可实现：自动拉取相关 git 服务器上最新文件，并压缩至 src/main/assets/hybird目录下，打包时就会自动带上最新的h5文件了。 解决上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445afterEvaluate &#123; tasks.matching &#123; it.name.startsWith('process') &amp;&amp; (it.name.endsWith('ReleaseJavaRes') || it.name.endsWith ('DebugJavaRes')) &#125;.each &#123; tk -&gt; tk.dependsOn(deletehybird) &#125;&#125;// clone hybird 文件task cloneHybird(type: Exec)&#123; delete file(\"src/main/assets/hybird\") def osName = System.getProperty(\"os.name\") if (osName.contains(\"Windows\")) &#123; commandLine 'cmd', '/c', 'git clone https://github.com/fenglincanyi/…… .git src/main/assets/hybird' &#125; else if (osName.contains(\"Mac OS\")) &#123; commandLine 'git', 'clone', ' https://github.com/fenglincanyi/…… .git', 'src/main/assets/hybird' &#125; else if (osName.contains(\"LINUX\"))&#123; commandLine 'git', 'clone', ' https://github.com/fenglincanyi/…… .git', 'src/main/assets/hybird' &#125; println(\"============== task cloneHybird ==============\")&#125;// 压缩 hybird文件task zipHybird(type: Zip) &#123; dependsOn cloneHybird if (file('src/main/assets/hybird.zip').lastModified() &gt;= file('src/main/assets/hybird').lastModified()) &#123;// 保证zip包最新 delete file(\"src/main/assets/hybird.zip\") &#125; archiveName = 'hybird.zip' destinationDir = file('src/main/assets') from 'src/main/assets/hybird/0.1' println(\"============== task hybirdZip ==============\")&#125;// 删除 hybird 目录及文件，只留 hybird.ziptask deletehybird(type: Delete) &#123; dependsOn zipHybird delete \"src/main/assets/hybird\" println(\"============== deletehybird ==============\")&#125; 此处，单独运行 task，演示效果： build 结果： 在 assets 目录下生成： 遇到的问题Mac系统执行 commandLine 去 clone 时，每次都报错： 12345678910111213141516Caused by: org.gradle.process.internal.ExecException: A problem occurred starting process 'command 'git clone https://github.com/fenglincanyi/…… .git''11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at org.gradle.process.internal.DefaultExecHandle.setEndStateInfo(DefaultExecHandle.java:197)11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at org.gradle.process.internal.DefaultExecHandle.failed(DefaultExecHandle.java:327)11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at org.gradle.process.internal.ExecHandleRunner.run(ExecHandleRunner.java:86)11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] ... 2 more11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] Caused by: net.rubygrapefruit.platform.NativeException: Could not start 'git clone https://github.com/fenglincanyi/…… .git'11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:27)11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at net.rubygrapefruit.platform.internal.WrapperProcessLauncher.start(WrapperProcessLauncher.java:36)11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at org.gradle.process.internal.ExecHandleRunner.run(ExecHandleRunner.java:68)11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] ... 2 more11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] Caused by: java.io.IOException: Cannot run program \"git clone https://github.com/fenglincanyi/…… .git\" (in directory \"/Users/geng/AndroidStudioProjects/GradleTest/app\"): error=2, No such file or directory11:38:32.043 [ERROR] [org.gradle.BuildExceptionReporter] at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25)11:38:32.044 [ERROR] [org.gradle.BuildExceptionReporter] ... 4 more11:38:32.044 [ERROR] [org.gradle.BuildExceptionReporter] Caused by: java.io.IOException: error=2, No such file or directory11:38:32.044 [ERROR] [org.gradle.BuildExceptionReporter] ... 5 more11:38:32.044 [ERROR] [org.gradle.BuildExceptionReporter] 最后Google半天，在 Mac 或 Linux 系统下，需要将命令中的字符串 逐个分割： 1commandLine 'git', 'clone', ' https://github.com/fenglincanyi/…… .git', 'src/main/assets/hybird' Gradle 官网的文档，说明的并不是很详细，这里要吐槽下。。。 总结 Gradle 基于Groovy实现，内置了许多好用的API，如：copy，zip等等，这些都可以将传统开发中的手动执行实现自动化 Gradle 的确方便了开发者，使用脚本来实现繁琐和重复的工作，也将开发过程中配置工作变得更加灵活 参考：https://www.jeeboot.com/archives/1563.htmlhttp://stackoverflow.com/questions/15776431/in-gradle-tasks-of-type-exec-why-do-commandline-and-executable-behave-differenthttps://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html#org.gradle.api.tasks.Exec:commandLine(java.lang.Object%5B%5Dhttps://segmentfault.com/q/1010000004503896","tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://fenglincanyi.github.io/tags/Gradle/"}]},{"title":"Springmvc 相关","date":"2017-01-21T06:55:00.000Z","path":"2017/01/21/Springmvc 相关/","text":"springmvc 框架原理 springmvc执行流程： 前端控制器（DispatcherServlet）, 接受请求，然后请求 处理器映射器（HanderMapping） HanderMapping 根据 xml / 注解 进行查找相关的 handler，并返回给 前端控制器 前端控制器 调用 处理器适配器（HanderAdapter）按照一定规则去执行 handler handler执行完毕后，返回给 HanderAdapter ModelAndView，HandlerAdapter 再返回给 前端控制器 前端控制器 将 ModelAndView 发送给 视图解析器（ViewResolver），试图解析器根据试图名解析为真正的视图 视图解析器解析后，将view 返回给 前端控制器，前端控制器 进行视图渲染，视图渲染将模型数据(在ModelAndView对象中)填充到request域 前端控制器 向用户相应结果 重要的组件： 前端控制器 DispatherServlet：接受请求，相应结果，转发器的作用 处理器映射器 HandlerMapping: 根据配置查找 handler 处理器适配器 HandlerAdapter: 按照规则去执行 handler 处理器 Handler: 业务处理 视图解析器 ViewResolver: 进行视图解析，将ModelAndView解析为真正的view springmvc 基本配置如果不在 springmvc.xml 配置相关的映射器、适配器，spring会使用默认的，默认的配置 在 DispatcherServlet.properties 中：这些默认的都不建议使用了。 123456789101112131415161718192021222324# Default implementation classes for DispatcherServlet's strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager Spring 3.1之后 使用的 映射器 和 适配器： org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMappingorg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter springmvc.xml 中的约束配置，参考文档进行配置： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;/beans&gt; 基本配置：web.xml： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;springmvcdemo1&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 设置 springmvc 的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvcConfig.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 访问 action 结尾的，由 DispatcherServlet 来解析--&gt; &lt;!--http://localhost:8080/springmvcdemo1/queryItems.action--&gt; &lt;!--&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;--&gt; &lt;!--http://localhost:8080/springmvcdemo1/queryItems--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml 基本配置： 1234567891011121314151617181920212223242526272829&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\"&gt; &lt;!-- 注解的 映射器、适配器--&gt; &lt;!--&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt;--&gt; &lt;!--&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt;--&gt; &lt;!-- 此配置默认 设置了 映射器、适配器，而且加载了许多的参数绑定，如json的自动转换 开发时候使用它 ： --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 使用扫描controller,service等等 --&gt; &lt;context:component-scan base-package=\"com.gjr.controller\"/&gt;&lt;/beans&gt; 参数绑定此处举例，具体看项目@RequestMap中的简单类型，直接安装相关参数进行设置即可对于包装类型 pojo, 客户端请求时候，相关的参数必须要和Pojo的属性名称一致 如： 12345678public class ItemsQueryVo &#123; // 商品信息 private Items items; // 为了扩展性，对生成的 po 进行扩展 private ItemsCustom itemsCustom;&#125; 12345@RequestMapping(value = \"/editItemsSubmit\")public ModelAndView editItemsSubmit(Integer id, ItemsQueryVo itemsQueryVo) throws Exception &#123; return modelAndView;&#125; 前端页面请求时候，表单信息中： 1&lt;input name=“itemsCustom.name” …/&gt; Spring 校验相关使用的是 Hibernate 的校验框架： 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.4.Final&lt;/version&gt;&lt;/dependency&gt; 具体看项目。。。 附录demo 地址：https://github.com/fenglincanyi/ssmdemo","tags":[{"name":"Springmvc","slug":"Springmvc","permalink":"https://fenglincanyi.github.io/tags/Springmvc/"}]},{"title":"Mybatis 逆向工程","date":"2017-01-17T02:11:00.000Z","path":"2017/01/17/Mybatis 逆向工程/","text":"pom 配置pom.xml 中 加入： 1234567891011&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; maven配置 命名：mybatis-generator:generate -e 注意：文件名必须是：generatorConfig.xml否则报错： configfile /Users/geng/ssm/Demo/ssmdemo/src/main/resources/generatorConfig.xml does not exist mybatis config.xml 文件配置拷贝驱动包的绝对路径 xml 配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\" &gt;&lt;generatorConfiguration&gt; &lt;!-- !!!! Driver Class Path !!!! —&gt; &lt;classPathEntry location=\"/Users/geng/ssm/Demo/mybaitsdemo2/src/main/resources/mysql-connector-java-5.1.7-bin.jar\"/&gt; &lt;context id=\"context\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"false\"/&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!-- !!!! Database Configurations !!!! --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis_demo2_db?characterEncoding=utf-8\" userId=\"root\" password=\"root\"/&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- !!!! Model Configurations !!!! --&gt; &lt;javaModelGenerator targetPackage=\"com.gjr.testgenerator.po\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- !!!! Mapper XML Configurations !!!! --&gt; &lt;sqlMapGenerator targetPackage=\"com.gjr.testgenerator.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- !!!! Mapper Interface Configurations !!!! --&gt; &lt;javaClientGenerator targetPackage=\"com.gjr.testgenerator.mapper\" targetProject=\"src/main/java\" type=\"XMLMAPPER\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- !!!! Table Configurations !!!! --&gt; &lt;table tableName=\"items\" enableCountByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableUpdateByExample=\"false\"/&gt; &lt;table tableName=\"orders\" enableCountByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableUpdateByExample=\"false\"/&gt; &lt;table tableName=\"orderdetail\" enableCountByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableUpdateByExample=\"false\"/&gt; &lt;table tableName=\"user\" enableCountByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableUpdateByExample=\"false\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行逆向生成代码 运行成功 附录demo 地址：https://github.com/fenglincanyi/mybaitsdemo2","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://fenglincanyi.github.io/tags/Mybatis/"}]},{"title":"Mybatis 学习（二）","date":"2017-01-15T06:32:00.000Z","path":"2017/01/15/Mybatis 学习（二）/","text":"本次学习内容：MyBatis 高级结合demo进行学习 2张表关联查询，一对一查询 需求查询订单的信息及用户信息 1234selectorders.*,user.username,user.sex, user.addressfrom orders, userwhere orders.user_id=user.id 结果集： 主要对 结果集 进行分析，再书写 mapper.xml resultType实现新建一个 po , 继承自 Orders（因为此sql 中 orders表的字段较多），再增加 user 的几个字段即可. 1234567891011121314151617181920212223242526272829303132333435public class OrdersCustom extends Orders&#123; // 需求： // select orders.*,user.username,user.sex, user.address // from orders, user // where orders.user_id=user.id private String username; private String sex; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 12345public interface OrdersCustomMapper &#123; // 一对一查询 使用 resultType实现 List&lt;OrdersCustom&gt; queryOrdersUser();&#125; 123456&lt;select id=\"queryOrdersUser\" resultType=\"com.gjr.po.OrdersCustom\"&gt; select orders.*,user.username,user.sex, user.address from orders, user where orders.user_id=user.id&lt;/select&gt; resultMap实现需要使用 association 进行关联，在原来的 Orders 类中 添加 user 属性 123456789101112/*** 一对一查询：使用 resultMap实现，优点：可实现懒加载*/private User user;public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; 123456&lt;select id=\"queryOrdersUser1\" resultMap=\"OrdersUserResultMap\"&gt; select orders.*,user.username,user.sex, user.address from orders, user where orders.user_id=user.id&lt;/select&gt; 12345678910111213141516&lt;resultMap id=\"OrdersUserResultMap\" type=\"com.gjr.po.Orders\"&gt; &lt;!-- 配置订单信息 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;!-- 配置用户信息 --&gt; &lt;association property=\"user\" javaType=\"com.gjr.po.User\"&gt; &lt;!-- 这个 property=\"user\" 就是 com.gjr.po.Orders 中增加的那个 user 属性--&gt; &lt;id column=\"user_id\" property=\"id\"/&gt; &lt;!-- column=\"user_id\" 是查出来的结果中 用户的 唯一标示 --&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;result column=\"address\" property=\"address\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 3张表关联查询，一对多查询确定主表，对其 po 添加所需字段 需求– 查询用户订单详情 123456789selectorders.*,user.username,user.sex, user.address,orderdetail.id orderdetail_id,orderdetail.items_id,orderdetail.items_num,orderdetail.orders_idfrom orders, user, orderdetailwhere orders.user_id = user.id and orders_id = orders.id 结果集： 实现 12345678910111213141516171819202122&lt;select id=\"queryOrdersDetailUser\" resultMap=\"OrdersDetailUserMap\"&gt;select orders.*, user.username,user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_idfrom orders, user, orderdetailwhere orders.user_id = user.id and orders_id = orders.id&lt;/select&gt;&lt;resultMap id=\"OrdersDetailUserMap\" type=\"com.gjr.po.Orders\" extends=\"OrdersUserResultMap\"&gt; &lt;!-- 用户信息、订单信息、复用前面的--&gt; &lt;collection property=\"orderdetailList\" ofType=\"com.gjr.po.Orderdetail\"&gt; &lt;!--使用 ofType--&gt; &lt;id column=\"orderdetail_id\" property=\"id\"/&gt; &lt;result column=\"items_id\" property=\"itemsId\"/&gt; &lt;result column=\"items_num\" property=\"itemsNum\"/&gt; &lt;result column=\"orders_id\" property=\"ordersId\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 在查询主表对应的po类， Orders 中增加字段 1private List&lt;Orderdetail&gt; orderdetailList; 3张表联合查询，多对多查询 需求查询用户订单商品明细 123456789101112131415161718SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name, items.detail items_detail, items.price items_priceFROM orders, user, orderdetail, itemsWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id 结果集： 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;select id=\"queryOrdersDetailUserItems\" resultMap=\"OrdersDetailUserItemsMap\"&gt;-- 查询用户订单商品明细 SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name, items.detail items_detail, items.price items_price FROM orders, user, orderdetail, items WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id &lt;/select&gt;&lt;resultMap id=\"OrdersDetailUserItemsMap\" type=\"com.gjr.po.User\"&gt; &lt;!-- 用户信息--&gt; &lt;id column=\"user_id\" property=\"id\"/&gt; &lt;!-- 根据查询结果 写 column !!! --&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;result column=\"address\" property=\"address\"/&gt; &lt;!-- 订单信息: 一个用户对应多个订单--&gt; &lt;collection property=\"ordersList\" ofType=\"com.gjr.po.Orders\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;!-- 订单明细：一个订单对应多个明细 --&gt; &lt;collection property=\"orderdetailList\" ofType=\"com.gjr.po.Orderdetail\"&gt; &lt;id column=\"orderdetail_id\" property=\"id\"/&gt; &lt;result column=\"items_id\" property=\"itemsId\"/&gt; &lt;result column=\"items_num\" property=\"itemsNum\"/&gt; &lt;result column=\"orders_id\" property=\"ordersId\"/&gt; &lt;!-- 商品信息：一个明细对应一个商品 --&gt; &lt;association property=\"items\" javaType=\"com.gjr.po.Items\"&gt; &lt;id column=\"items_id\" property=\"id\"/&gt; &lt;result column=\"items_name\" property=\"name\"/&gt; &lt;result column=\"items_detail\" property=\"detail\"/&gt; &lt;result column=\"items_price\" property=\"price\"/&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt; 各个 po 类需要分别增加相关字段即可，安装关联的类型和字段 懒加载配置 mybatisConfig.xml 相关参数： 123456&lt;settings&gt; &lt;!-- 打开 延迟加载 的开关--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 设置按需加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 1234 &lt;select id=\"findOrdersUserLazyLoading\" resultMap=\"OrdersUserLazyLoadingResultMap\"&gt;-- 懒加载测试 SELECT * FROM orders &lt;/select&gt; 用 association 实现延迟加载： 123456789101112131415&lt;resultMap id=\"OrdersUserLazyLoadingResultMap\" type=\"com.gjr.po.Orders\"&gt; &lt;!--对订单信息进行映射配置 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;association property=\"user\" javaType=\"com.gjr.po.User\" select=\"com.gjr.mapper.UserMapper.findUserById\" column=\"user_id\"&gt; &lt;!-- 实现对用户信息进行延迟加载 --&gt; &lt;/association&gt;&lt;/resultMap&gt; 测试： mybatis 缓存相关 mybatis默认开启一级缓存，二级缓存 Mybatis查询得数据，缓存至一级缓存，再缓存至二级缓存中，二级缓存是 mapper 级别的，凡是同一个mapper，都会有自己的二级缓存区 多个sqlsession可以同享同一个 mapper的二级缓存 总结 resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。 延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 查询结果 必须要和 pojo 类型保持一致 联系实际问题的关系类型（如：一个订单对应一个用户，一个订单对应多个明细），进行 po 的修改或扩展 association, collection 分别是 关系类型为：1对1，1对多 配置时分别是 javaType 、ofType 附录demo 地址：https://github.com/fenglincanyi/mybaitsdemo2","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://fenglincanyi.github.io/tags/Mybatis/"}]},{"title":"Mybatis 学习（一）","date":"2017-01-11T04:01:00.000Z","path":"2017/01/11/Mybatis 学习（一）/","text":"本次学习内容：MyBatis 基础 介绍mybatis 是一个持久层框架，是apache下的开源项目是一个半自动化框架，与Hibernate相比，需要开发者手动写sql，这样更为灵活配置mybatis 可以将PreparedStatement 中输入的参数自动进行输入映射，将查询结果灵活映射成 Java 对象 基本原理执行过程： SqlMapConfig.xml/mapper.xml … —&gt;SqlSessionFactory —&gt;SqlSession —&gt;Executor —&gt;mapper statement —&gt;db 配置数据源，映射文件 创建SqlSession 交给执行器操作数据库 操作数据库 对操作数据库存储做封装，包括SQL语句，输入参数，输出结果 遇到问题报错：org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): ………然后，发现target目录下，XxxMapper.xml 没有在 target 下相应的目录生成 原因： 在使用maven等构建工具时，默认会将源码编译后再加上资源目录的文件放到target目录下作为最后运行的文件（可以是war,jar,或者目录）。有时为了方便，我们会在src/main/java源码目录下放了资源文件，例如mybatis的mapper文件，方便我们编程时展开查看。这时，我们需要设置编译时也将这些配置文件放到target目录下，否则最后的target目录式没有这些文件的。 解决：在maven中，在build元素中添加： 12345678910&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 总结 Mybatis 框架实际上 是对原来 jdbc 代码的封装，将繁琐重复的代码，交付给配置文件和接口类进行灵活的对象映射 动态sql 有点像 jstl，很容易理解，目的就是为了灵活的玩 sql 语句 对于各种类型的sql 语句，需要记住mybatis的处理方式即可 Mybatis 是将 对象或简单类型输入，将结果以数据实体/简单类型输出，省去了 jdbc 的复杂操作 进行 事务性操作时，一定要 commit，否则不生效sqlSession.commit(); mybatis 插件附录： 使用：https://www.oschina.net/p/intellij-mybatis-plugin 下载：https://github.com/CHN-Jaylin/Plugins-Cracked （破解的) 参考：http://ask.csdn.net/questions/226091 附录demo 地址：https://github.com/fenglincanyi/mybaitsdemo1","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://fenglincanyi.github.io/tags/Mybatis/"}]},{"title":"Spring 学习（三）","date":"2017-01-07T04:01:00.000Z","path":"2017/01/07/Spring 学习（三）/","text":"本次学习内容：Spring AOP相关 问题引入123456public class User &#123; public void addUser() &#123; // ... &#125;&#125; —— 需求，在上面原有的功能中，加入用户日志，记录用户信息？如何做？—— 方法尝试： 123456public class BaseUser &#123; public void writeLog() &#123; // 写日志，记录用户信息 &#125;&#125; 1234567public class User extends BaseUser&#123; public void addUser() &#123; // ... super.writeLog(); &#125;&#125; 这种 纵向 的抽取，并不能友好的解决问题，一旦父类的名称改变，后面也要接着更改 AOP 原理有接口1234567891011public interface Dao &#123; void add();&#125;public class DaoImpl implements Dao &#123; public void add() &#123; &#125;&#125; 使用 jdk 动态代理，生成 接口实现类的代理对象，来增相应方法的功能 没有接口12345public class User &#123; public void addUser() &#123; &#125;&#125; 使用 cglib 动态代理，生成其子类的代理对象，调用父类的方法，来增强相应功能 几个重要 术语 连接点 JoinPoint：类中哪些方法可以被 增强，这些方法就是 连接点 切入点 PointCut：类中实际增强类那些方法（如：add,update)，这些方法称为 切入点 通知／增强 advice: 增强的逻辑，如：要扩展日志功能，则日志功能为 增强／通知分为：前置通知(方法之前执行），后置通知，异常通知(方法出现异常)，最终通知(后置之后执行)，环绕通知(方法之前和之后执行) 切面 aspect：把增强功能应用到具体方法上，这个过程叫切面。即：把增强应用到切入点的过程 目标对象 target: 要增强的类，代理的目标对象 织入 weaving: 把增强应用到目标的过程，把advice 应用到target的过程 代理 Proxy: 一个类被aop织入增强后，就产生一个结果代理类 实现AOPxml 配置实现 切入点配置表达式：execution(&lt;访问修饰符&gt; &lt;返回类型&gt;&lt;方法名&gt;(参数)&lt;异常&gt;）e.g. execution(* com.gjr.aop.Book.add(..)) execution(* com.gjr.aop.Book.*(..)) book 类下的所有方法加强 execution(* *.*(..)) 所有类下的所有方法加强 execution(* xxx*(..)) 所有xxx开头的方法加强 demo 示例： 1234567891011121314151617181920212223public class Book &#123; public void show() &#123; System.out.println(\"show book ....\"); &#125;&#125;public class MyBook &#123; public void addFunctionBefore() &#123; System.out.println(\"在前面，加点功能 。。。\"); &#125; public void addFunctionAfter() &#123; System.out.println(\"在后面，加点功能 。。。\"); &#125; public void arroundFunction(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(\"之前环绕 。。。\"); proceedingJoinPoint.proceed(); System.out.println(\"之后环绕 。。。\"); // 注意 环绕通知 的参数：ProceedingJoinPoint &#125;&#125; xml配置： 1234567891011121314151617181920212223&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 加入 aop 约束，xml 配置aop 来实现功能—&gt; &lt;bean id=\"book\" class=\"com.gjr.aspect.Book\"/&gt; &lt;bean id=\"myBook\" class=\"com.gjr.aspect.MyBook\"/&gt; &lt;aop:config&gt; &lt;!-- 切点: 需要被增强功能的方法 --&gt; &lt;aop:pointcut id=\"bookPoint\" expression=\"execution(* com.gjr.aspect.Book.show(..))\"/&gt; &lt;!-- 切面: 把增强方法加到需要增强的方法上 --&gt; &lt;aop:aspect ref=\"myBook\"&gt; &lt;aop:before method=\"addFunctionBefore\" pointcut-ref=\"bookPoint\"/&gt; &lt;aop:after method=\"addFunctionAfter\" pointcut-ref=\"bookPoint\"/&gt; &lt;aop:around method=\"arroundFunction\" pointcut-ref=\"bookPoint\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 3种 切面类型同时存在时：before最先调用，after最后调用 注解实现 aop（只列出@Before，其他的相同）1234567891011121314public class Order &#123; public void show() &#123; System.out.println(\"show order ...\"); &#125;&#125;@Aspectpublic class MyOrder &#123; @Before(value = \"execution(* Order.show(..))\") public void addFunction() &#123; System.out.println(\"add function ...\"); &#125;&#125; 12345&lt;bean id=\"order\" class=\"com.gjr.annaop.Order\"/&gt;&lt;bean id=\"myOrder\" class=\"com.gjr.annaop.MyOrder\"/&gt;&lt;!-- 注解 实现 aop--&gt;&lt;aop:aspectj-autoproxy/&gt; Spring 相关的 pom 配置 GroupId ArtifactId Description org.springframework spring-aop Proxy-based AOP support org.springframework spring-aspects AspectJ based aspects org.springframework spring-beans Beans support, including Groovy org.springframework spring-context Application context runtime, including scheduling and remoting abstractions org.springframework spring-context-support Support classes for integrating common third-party libraries into a Spring application context org.springframework spring-core Core utilities, used by many other Spring modules org.springframework spring-expression Spring Expression Language (SpEL) org.springframework spring-instrument Instrumentation agent for JVM bootstrapping org.springframework spring-instrument-tomcat Instrumentation agent for Tomcat org.springframework spring-jdbc JDBC support package, including DataSource setup and JDBC access support org.springframework spring-jms JMS support package, including helper classes to send and receive JMS messages org.springframework spring-messaging Support for messaging architectures and protocols org.springframework spring-orm Object/Relational Mapping, including JPA and Hibernate support org.springframework spring-oxm Object/XML Mapping org.springframework spring-test Support for unit testing and integration testing Spring components org.springframework spring-tx Transaction infrastructure, including DAO support and JCA integration org.springframework spring-web Web support packages, including client and web remoting org.springframework spring-webmvc REST Web Services and model-view-controller implementation for web applications org.springframework spring-webmvc-portlet MVC implementation to be used in a Portlet environment org.springframework spring-websocket WebSocket and SockJS implementations, including STOMP support 附录demo 地址：https://github.com/fenglincanyi/springdemo2","tags":[{"name":"Spring","slug":"Spring","permalink":"https://fenglincanyi.github.io/tags/Spring/"}]},{"title":"Spring 学习（二）","date":"2016-12-27T09:01:00.000Z","path":"2016/12/27/Spring 学习（二）/","text":"本次学习内容：Spring 依赖注入相关 xml 配置实现setXXX() 方法注入123&lt;bean id=\"book\" class=\"com.geng.attr.Book\"&gt; &lt;property name=\"bookName\" value=\"西游记\"/&gt;&lt;/bean&gt; 构造方法注入1234// 这里通过有参构造注入&lt;bean id=\"people\" class=\"com.geng.attr.People\"&gt; &lt;constructor-arg name=\"name\" value=\"小明\"/&gt;&lt;/bean&gt; 对象注入1234&lt;bean id=\"userDao\" class=\"com.geng.obj.UserDao\"/&gt;&lt;bean id=\"userService\" class=\"com.geng.obj.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt;&lt;/bean&gt; 123456public class UserDao &#123; public void showUserDao() &#123; System.out.println(\"show user dao...\"); &#125;&#125; 1234567891011121314public class UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void showService() &#123; System.out.println(\"show Service....\"); userDao.showUserDao(); &#125;&#125; 测试： 12345678910111213141516public class UserServiceTest &#123; private ApplicationContext context; @Before public void setUp() throws Exception &#123; context = new ClassPathXmlApplicationContext(\"beans1.xml\"); &#125; @Test public void showService() throws Exception &#123; UserService userService = (UserService) context.getBean(\"userService\"); userService.showService(); &#125;&#125; p命名空间注入xml 头部加入： 1xmlns:p=\"http://www.springframework.org/schema/p\" 配置： 1&lt;bean id=\"person\" class=\"com.geng.attr.Person\" p:pName=\"呵呵哒”/&gt; 123456789101112public class Person &#123; private String pName; public void setpName(String pName) &#123; this.pName = pName; &#125; public void test() &#123; System.out.println(\"result: \" + pName); &#125;&#125; 复杂类型注入123456789101112131415161718192021222324252627282930public class MulitDemo &#123; private String[] arrs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Properties properties; public void setArrs(String[] arrs) &#123; this.arrs = arrs; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void showAll() &#123; System.out.println(arrs); System.out.println(list); System.out.println(map); System.out.println(properties); &#125;&#125; xml 分别配置：123456789101112131415161718192021222324252627282930313233&lt;bean id=\"mulitDemo\" class=\"com.geng.collection.MulitDemo\"&gt; &lt;property name=\"arrs\"&gt; &lt;array&gt; &lt;value&gt;小红&lt;/value&gt; &lt;value&gt;小白&lt;/value&gt; &lt;value&gt;小绿&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;大白&lt;/value&gt; &lt;value&gt;大春&lt;/value&gt; &lt;value&gt;大花&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"001\" value=\"小白\" /&gt; &lt;entry key=\"002\" value=\"小刘\" /&gt; &lt;entry key=\"003\" value=\"小东\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"driveClass\"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"userName\"&gt;root&lt;/prop&gt; &lt;prop key=\"userPwd\"&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 测试： 注解实现12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 上面 加入 spring-context 约束，参照spring文档： 41.2.8 the context schema；否则，无法使用 context标 签 --&gt;&lt;/beans&gt; 创建对象注解 @Component @Controller —— web 层 @Service —— 业务层 @Repository —— 持久层 以上4个注解 功能是一致的，都是用于创建对象，作用在 类 上，只是为了后期方便扩展 对象的 scope1@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 默认是 singleton 可查看源码进行设置 对象属性注入 @Autowired：自动装配 @Resource(name=“userDao”) 指定创建哪种类型的对象 1234567@Component(value = \"userDao\")public class UserDao &#123; public void showUserDao() &#123; System.out.println(\"show user dao ...\"); &#125;&#125; 12345678910111213141516@Service(value = \"userService\")public class UserService &#123; // 1. 第一种// @Autowired// private UserDao userDao;// 要使用UserDao的对象，使用自动装配 // 2. 第二种 @Resource(name = \"userDao\") // name 值必须和 UserDao 内的value值必须一样，否则报错：no such bean is defined private UserDao userDao;// 这种是明确指定创建哪种类型的对象，比较常用 public void showUserService() &#123; System.out.println(\"show user service ...\"); userDao.showUserDao(); &#125;&#125; 测试： xml 配置注入 和 注解注入 两种可以联合使用，用法和前面一样，不再举例。 IOC 与 DI 区别IOC ：控制反转，将创建对象交给 Spring 的配置来完成DI ：将对象的属性赋值 DI 是依赖于 ioc 才能完成操作，不能单独存在 附录：demo地址：https://github.com/fenglincanyi/springdemo1https://github.com/fenglincanyi/springdemo2","tags":[{"name":"Spring","slug":"Spring","permalink":"https://fenglincanyi.github.io/tags/Spring/"}]},{"title":"Spring 学习（一）","date":"2016-12-26T06:06:00.000Z","path":"2016/12/26/Spring 学习（一）/","text":"Spring的2个基本概念 aop面向切面编程在原有的基础上进行扩展，而不是进行修改。符合 开闭原则 ioc控制反转不通过手动 new 方式，来创建对象，而是交给Spring 容器根据配置，进行创建。从而将类的对象交给Spring 进行控制管理 ioc 的2种方式来创建对象：（1）通过配置文件（2）通过注解 ioc 实现原理 通过dom4j 解析 xml 文件，拿到类的全路径，然后通过反射的技术创建该类的对象，结合工厂模式返给调用方伪代码实现说明： 1&lt;bean id=“userService” class=“com.geng.UserService” /&gt; 1234567public class Factory &#123; public static UserService getUserService() &#123; String classValue = dom4j.getValue(“userService”); Class clazz = Class.forName(“classValue”); return clazz.newInstance(); &#125;&#125; Spring 运行时 Spring 提供了全面的Java web 服务框架，从web层到业务层，再到持久层，都有着相关模块的实现。对于Spring 最基本使用，必须尹若 Core Container中的4个重要的部分，方可使用。若只引用某部分的库，maven也会自动引用最核心的jar包到你的应用中。 Spring 第一个Demo 开发在 idea 中，创建 maven 项目，然后，编辑 pom.xml 文件。引入：Spring 主要的几个库，log4j，junit 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在resource 目录下，创建 xml 配置文件，如图： Idea 在你编辑时候，会提示相关的属性，方便书写配置 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd”&gt; &lt;bean id=\"user\" class=\"com.geng.ioc.User\"/&gt;&lt;/beans&gt; 创建测试用例： 12345678910111213141516public class UserTest &#123; private ApplicationContext context; @Before public void setUp() throws Exception &#123; context = new ClassPathXmlApplicationContext(\"beans1.xml\"); &#125; @Test public void add() throws Exception &#123; User user = (User) context.getBean(\"user\"); user.add(); &#125;&#125; 至此，我们完成了第一个 Spring demo bean 的管理 通过无参构造创建（前面第一个demo） 通过静态工厂实现对象创建代码示例： 12345678910111213public class BeanFactory &#123; public static User2 createUser2() &#123; return new User2(); &#125;&#125;public class User2 &#123; public void add() &#123; System.out.println(\"user2.....”); &#125;&#125; xml中配置： 12&lt;!--用静态工厂创建--&gt;&lt;bean id=\"user2\" class=\"com.geng.ioc.BeanFactory\" factory-method=\"createUser2”/&gt; 测试： 1234567891011121314151617public class User2Test &#123; private ApplicationContext context; @Before public void setUp() throws Exception &#123; context = new ClassPathXmlApplicationContext(\"beans1.xml\"); &#125; @Test public void add() throws Exception &#123; User2 user2 = (User2) context.getBean(\"user2\"); System.out.println(user2); user2.add(); &#125;&#125; 通过实例工厂创建对象 123&lt;!--用实例工厂创建—&gt;&lt;bean id=\"bean2Factory\" class=\"com.geng.ioc.Bean2Factory\" /&gt;&lt;bean id=\"user2\" factory-bean=\"bean2Factory\" factory-method=\"getBean\"/&gt; 这里不再验证。。。 Spring配置文件中的几个重要属性id：不能还有特殊符号，“_”是可以的name：可以含有特殊符号，如：#，历史版本中使用的，后期不推荐使用。context.getBean() 方法可以获取这两种属性的值class：类的全路径scope：作用域 singleton(默认) prototype(多例) request 创建对象放在request域 session 创建对象放在session域 globalSession 一次登陆，任何地方都保存有登录状态 附录：IDEA Resource 目录下，存放的文件类型 （IDEA 官网：https://www.jetbrains.com/help/idea/2016.3/resource-files.html ） 所以，在此目录下，我们一般存放配置文件，或一些必要的资源文件。 Demo 地址：https://github.com/fenglincanyi/springdemo1","tags":[{"name":"Spring","slug":"Spring","permalink":"https://fenglincanyi.github.io/tags/Spring/"}]},{"title":"instant run 相关分析","date":"2016-12-17T05:00:00.000Z","path":"2016/12/17/instant run 相关分析/","text":"Android Studio 2.0 引入了即时编译功能：instant run，一定程度上进行了增量编译、增量更新代码，节省了开发耗时（喝咖啡的时间）。下面具体分析下instant run相关工作流程和相关的源码 instant run 使用版本要求Gradle 2.0 以上build.gradle：minSdkVersion 15 以上（设置21以上可获得最佳性能）Android 5.0以上的手机或模拟器 使用首先确认开启instant run，在settings中搜索instant run，可看到相关设置，默认instant run功能是开启的 当第一次点击 run 按钮 ，进行第一次编译打包。apk成功安装之后，再观察工具栏，run按钮发生了变化： 然后我们随意修改一部分代码，点击运行，可看到手机屏幕上弹出toast，提示代码已经改变了，可看到最新的运行效果。使用起来也比较方便、快捷。 更新方式 热交换 hot swap更改现有方法的实现代码；不会重新初始化正在运行的app，不要做重启app，activity的操作，即可看到最新代码运行结果 温交换 warm swap更改或移除当前的资源；activity会自动重启（小闪烁），即可看到最新运行结果 冷交换 cold swap对代码有结构性的更改（字段更改、类继承关系、清单文件更改）；此时会重启app 参考：https://developer.android.com/studio/run/index.html?hl=zh-cnhttps://medium.com/google-developers/instant-run-how-does-it-work-294a1633367f#.go1u6yq2o 过程分析第一次打包instant run 第一次编译打包流程，会执行下面的工作 先来看看生成的apk： 多出了 instant-run.zip文件，那它里面是什么内容呢？ instant-run.zip里的dex文件，是我们真正的业务代码 那instant run 相关的类呢，反而跑到了外层的classes.dex和classes2.dex中。 实际上这2个dex中的内容是instant-run.jar和instant-run-bootstrap.jar 的内容（自己可反编译出来看看）： 就是说，第一次运行打包时候，是将 instant-run.jar 和 instant-run-bootstrap.jar 2个jar 变成 2个dex文件，真正的业务代码编译后整合到别的dex中，然后放在了instant-run.zip中 classes.dex -&gt; instant-run.jar &nbsp;&nbsp;&nbsp;&nbsp; instant run 相关api类classes2.dex -&gt; instant-run-bootstrap.jar &nbsp;&nbsp; AppInfo.class 再来看看清单文件，application 被替换成 BootstrapApplication： instant run 代码分析attachBaseContext() 中执行的三个步骤首先来观察下该类下的 attachBaseContext()方法，其中做了3个比较重要的事情：createResources() 、setupClassLoaders()、createRealApplication() createResources()主要是判断资源resource.ap是否改变，然后保存resource.ap的路径到externalResourcePath中 setupClassLoaders()设置instant run 相关的classLoader，及其继承关系（PathClassLoader -&gt; BootClassLoader 变为 PathClassLoader -&gt; IncrementalClassLoader -&gt; BootClassLoader） createRealApplication()进行application 的相关替换，当前app的application变为realApplication；反射的方式拿到 真实的 Application，通过AppInfo相关字段进行获取 下面我们分析一下setClassLoader详细过程：主要经历了以下的方法： 这几个ClassLoader类定义的逻辑关系如下： findClass过程依次委托给 父ClassLoader，最后是让PathClassLoader去加载类 onCreate() 过程 通过MonkeyPatcher 替换当前的 application 为 realApplication包含ActivityThread中相应的Application 都替换成 realApplication 替换相应的资源resource替换当前app的assetManager，资源相关的变量等等（期间都是用反射的方式） Server 创建，建立Socket连接，开启连接 Server 部署工作在Server 建立起连接后，三种部署工作（hot swap、warm swap、cold swap），都是通过Server进行操作。具体在那种情形下进行哪种交换，源码中有具体实现： 12345678910111213141516171819202122232425262728293031323334private int handlePatches(List&lt;ApplicationPatch&gt; paramList, boolean paramBoolean, int paramInt) &#123; if (paramBoolean) &#123; FileManager.startUpdate(); &#125; Iterator localIterator = paramList.iterator(); while (localIterator.hasNext()) &#123; Object localObject = (ApplicationPatch) localIterator.next(); String str = ((ApplicationPatch) localObject).getPath(); if (str.endsWith(\".dex\")) &#123;// 冷交换 handleColdSwapPatch((ApplicationPatch) localObject); int j = 0; localObject = paramList.iterator(); do &#123; i = j; if (!((Iterator) localObject).hasNext()) &#123; break; &#125; &#125; while (!((ApplicationPatch) ((Iterator) localObject).next()).getPath().equals(\"classes.dex.3\")); int i = 1; if (i == 0) &#123; paramInt = 3; &#125; &#125; else if (str.equals(\"classes.dex.3\")) &#123;// 热交换 paramInt = handleHotSwapPatch(paramInt, (ApplicationPatch) localObject); &#125; else if (isResourcePath(str)) &#123;// 资源：温交换 paramInt = handleResourcePatch(paramInt, (ApplicationPatch) localObject, str); &#125; &#125; if (paramBoolean) &#123; FileManager.finishUpdate(true); &#125; return paramInt;&#125; 代码热更新流程在我们增加一行代码后，点击运行，我们来观察生成的类的变化在 build 目录下，transforms 中有生成相关的代码 几个重要类我们来具体看看demo 中代码更改：MainActivity$override类内容的确是最新的代码内容 AppPatchesLoaderImpl类记录了更改的类，存储在一个数组中，供类加载时候，替换成最新的类的代码内容 在此处，我反编译了slice_0-classes.dex： 第一次运行打包生成的 “业务代码” 中，生成的类中的方法里都增加了 IncrementalChange 相关的判断，如果 $change 不为空，说明我们有更改的代码，有更改的代码，则执行最新更改的代码 12345678910111213141516171819public Object access$dispatch(String paramString, Object... paramVarArgs) &#123; switch (paramString.hashCode()) &#123; case -833446436: initView((MainActivity) paramVarArgs[0]); return null; case -641568046: onCreate((MainActivity) paramVarArgs[0], (Bundle) paramVarArgs[1]); return null; case -399296056: return init$args((MainActivity[]) paramVarArgs[0], (Object[]) paramVarArgs[1]); case 781336394: init$body((MainActivity) paramVarArgs[0], (Object[]) paramVarArgs[1]); return null; case 2118315029: testClick((MainActivity) paramVarArgs[0], (View) paramVarArgs[1]); return null; &#125; throw new InstantReloadException(String.format(\"String switch could not find '%s' with hashcode %s in %s\", new Object[]&#123;paramString, Integer.valueOf(paramString.hashCode()), \"com/geng/myapplication/MainActivity\"&#125;)); &#125; 最后根据不同的类型，进行相关的重启（activity 或者 app），主要由 Restarter负责，同时也提供了相关的重启方法： restartActivity() restartApp() 至此，整个 instant run 的分析告一段落，需要慢慢消化一下。。。 源码及工具资源：https://github.com/fenglincanyi/Study/tree/master/instant%20run%E7%9B%B8%E5%85%B3参考：https://github.com/nuptboyzhb/AndroidInstantRun","tags":[{"name":"instant run","slug":"instant-run","permalink":"https://fenglincanyi.github.io/tags/instant-run/"}]},{"title":"Android WebView 相关踩坑","date":"2016-12-15T05:29:00.000Z","path":"2016/12/15/Android WebView 相关踩坑/","text":"url 传参 url 嵌套的问题问题场景get请求链接中： 传参中含有url “chinahr://customer/h5page?” + LEOGAO_PAGE+”=”+finishpage+”&amp;”+LEOGAO_ACTION+”=”+finishaction + “&amp;”+INTENT_URL+”=” + url 其中：url： file:///android_asset/hybird/cp/index.html?uid=” + cuid +”&amp;gender=”+gender +”&amp;photo=”+photoPath; 合并之后：“chinahr://customer/h5page?” + LEOGAO_PAGE+”=”+finishpage+”&amp;”+LEOGAO_ACTION+”=”+finishaction + “&amp;”+INTENT_URL+”=”+“file:///android_asset/hybird/cp/index.html?uid=” + cuid +”&amp;gender=”+gender +”&amp;photo=”+photoPath； 所以这个 url 中的 第二个及以后的参数第一次就会被router解析，并不会将 url 整体作为一个参数传到下一个页面中去再次解析识别。 解决方法Android端1234567891011JSONObject jsonObject = new JSONObject();try &#123; jsonObject.put(\"uid\", cUid); jsonObject.put(\"gender\", gender); jsonObject.put(\"photo\", potoPath); paramsResult = URLEncoder.encode(Base64.encodeToString(jsonObject.toString().getBytes(), Base64.DEFAULT));&#125; catch (JSONException e) &#123; e.printStackTrace();&#125;// 此处为加载本地，也可以为网络urlBaseH5Activity.startWebViewActivity(this, \"file:///android_asset/hybird/cp/index.html?params=\" + paramsResult, \"\",\"\",\"\",\"\"); 前端js12345678var me = this;var href = window.location.url || window.location.href;var params = me.getParams(href, 'params');params = Base64.decode(decodeURIComponent(params));info = JSON.parse(params);var uid = info.uid;var photo = info.photo;var gender = info.gender; 踩坑 第一次使用UrlEncoder编码，k可能会造成浏览器与js解析数据会存在不一致的问题解决：先使用base64进行编码，解决数据不一致的问题，再进行UrlEncoder编码（为了防止base64编码后的数据解析时：”+” 会当做空格的问题 ） 加载本地 html 时：直接设置 cookie 在 本地url 上是无效的，也是没有必要的。自己遇到的问题是：加载本地 html，此html中使用的 jsonp 请求网络，此时需要的cookie，需要设置 WebView 的cookie，使之持久化，下次会自动带 cookie 访问网络的。 Android 5.0 WebView 设置cookie问题 对于 Android 5.0 以上的WebView，默认关闭了接收三方cookie，但是提供了设置 cookie的接口，需要开发者去手动设置三方信任cookie。否则，加载本地 html 时，cookie 同步不过去。代码如下： 123456CookieManager cookieManager = CookieManager.getInstance();cookieManager.setAcceptCookie(true);cookieManager.setAcceptFileSchemeCookies(true);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.setAcceptThirdPartyCookies(webView, true);&#125; Android WebView 加载本地 html webview 加载 sd 卡下的 html 是不能访问的，权限问题。 如果访问 /data/data/包名/files/index.html，需要开启文件访问权限（默认是开启的，不要动态设置关闭）1webSettings.setAllowFileAccess(false);// 关闭 补充在线加解密、编码解析工具：http://tool.oschina.net/encrypt?type=3http://www.cnblogs.com/wangsu/articles/2917181.html","tags":[{"name":"h5","slug":"h5","permalink":"https://fenglincanyi.github.io/tags/h5/"}]},{"title":"Dalvik中PreVerify问题","date":"2016-11-24T05:01:00.000Z","path":"2016/11/24/Dalvik中PreVerify问题/","text":"PreVerify（预校验）的由来Dalvik 虚拟机在启动的时候，会有许多的启动参数，其中有一项就是verify，当verify被打开的时候，doVerify变量为true，则进行类的校验（dvmVerifyClass方法调用）。若校验成功，则这个类会被打上标记：CLASS_ISPREVERIFIED。上面描述的过程是dex -&gt; odex (dexopt 过程)时，做的一个优化。当从classes.dex 变为 odex 后，才会被拿去执行。 Class 被 Preverify 的过程在dex 被 dexopt 的过程中，源码中有校验和优化 Class 相关的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * Verify and/or optimize a specific class. */static void verifyAndOptimizeClass(DexFile* pDexFile, ClassObject* clazz, const DexClassDef* pClassDef, bool doVerify, bool doOpt)&#123; const char* classDescriptor; bool verified = false; if (clazz-&gt;pDvmDex-&gt;pDexFile != pDexFile) &#123; /* * The current DEX file defined a class that is also present in the * bootstrap class path. The class loader favored the bootstrap * version, which means that we have a pointer to a class that is * (a) not the one we want to examine, and (b) mapped read-only, * so we will seg fault if we try to rewrite instructions inside it. */ ALOGD(\"DexOpt: not verifying/optimizing '%s': multiple definitions\", clazz-&gt;descriptor); return; &#125; classDescriptor = dexStringByTypeIdx(pDexFile, pClassDef-&gt;classIdx); /* * First, try to verify it. */ if (doVerify) &#123; if (dvmVerifyClass(clazz)) &#123; /* * Set the \"is preverified\" flag in the DexClassDef. We * do it here, rather than in the ClassObject structure, * because the DexClassDef is part of the odex file. */ assert((clazz-&gt;accessFlags &amp; JAVA_FLAGS_MASK) == pClassDef-&gt;accessFlags); ((DexClassDef*)pClassDef)-&gt;accessFlags |= CLASS_ISPREVERIFIED; verified = true; &#125; else &#123; // TODO: log when in verbose mode ALOGV(\"DexOpt: '%s' failed verification\", classDescriptor); &#125; &#125; if (doOpt) &#123; bool needVerify = (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED || gDvm.dexOptMode == OPTIMIZE_MODE_FULL); if (!verified &amp;&amp; needVerify) &#123; ALOGV(\"DexOpt: not optimizing '%s': not verified\", classDescriptor); &#125; else &#123; dvmOptimizeClass(clazz, false);// 优化 Class 操作 /* set the flag whether or not we actually changed anything */ ((DexClassDef*)pClassDef)-&gt;accessFlags |= CLASS_ISOPTIMIZED;// Class被优化过后，也会打上被优化过的标记 CLASS_ISOPTIMIZED &#125; &#125;&#125; dvmVerifyClass 的具体过程，源码中是这样描述的： 1234567891011121314151617181920212223242526272829/* * Verify a class. * * By the time we get here, the value of gDvm.classVerifyMode should already * have been factored in. If you want to call into the verifier even * though verification is disabled, that's your business. * * Returns \"true\" on success. */bool dvmVerifyClass(ClassObject*clazz) &#123; int i; if (dvmIsClassVerified(clazz)) &#123; ALOGD(\"Ignoring duplicate verify attempt on %s\", clazz -&gt; descriptor); return true; &#125; for (i = 0; i &lt; clazz -&gt; directMethodCount; i++) &#123; if (!verifyMethod( &amp; clazz -&gt; directMethods[i]))&#123; LOG_VFY(\"Verifier rejected class %s\", clazz -&gt; descriptor); return false; &#125; &#125; for (i = 0; i &lt; clazz -&gt; virtualMethodCount; i++) &#123; if (!verifyMethod( &amp; clazz -&gt; virtualMethods[i]))&#123; LOG_VFY(\"Verifier rejected class %s\", clazz -&gt; descriptor); return false; &#125; &#125; return true;&#125; 其中，dvmVerifyClass中又去调用了 方法的校验 verifyMethod, 再去追源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/* * Perform verification on a single method. */static bool verifyMethod(Method* meth)&#123; bool result = false; /* * Verifier state blob. Various values will be cached here so we * can avoid expensive lookups and pass fewer arguments around. */ VerifierData vdata;#if 1 // ndef NDEBUG memset(&amp;vdata, 0x99, sizeof(vdata));#endif vdata.method = meth; vdata.insnsSize = dvmGetMethodInsnsSize(meth); vdata.insnRegCount = meth-&gt;registersSize; vdata.insnFlags = NULL; vdata.uninitMap = NULL; vdata.basicBlocks = NULL; /* * If there aren't any instructions, make sure that's expected, then * exit successfully. Note: for native methods, meth-&gt;insns gets set * to a native function pointer on first call, so don't use that as * an indicator. */ if (vdata.insnsSize == 0) &#123; if (!dvmIsNativeMethod(meth) &amp;&amp; !dvmIsAbstractMethod(meth)) &#123; LOG_VFY_METH(meth, \"VFY: zero-length code in concrete non-native method\"); goto bail; &#125; goto success; &#125; /* * Sanity-check the register counts. ins + locals = registers, so make * sure that ins &lt;= registers. */ if (meth-&gt;insSize &gt; meth-&gt;registersSize) &#123; LOG_VFY_METH(meth, \"VFY: bad register counts (ins=%d regs=%d)\", meth-&gt;insSize, meth-&gt;registersSize); goto bail; &#125; /* * Allocate and populate an array to hold instruction data. * * TODO: Consider keeping a reusable pre-allocated array sitting * around for smaller methods. */ vdata.insnFlags = (InsnFlags*) calloc(vdata.insnsSize, sizeof(InsnFlags)); if (vdata.insnFlags == NULL) goto bail; /* * Compute the width of each instruction and store the result in insnFlags. * Count up the #of occurrences of certain opcodes while we're at it. */ if (!computeWidthsAndCountOps(&amp;vdata)) goto bail; /* * Allocate a map to hold the classes of uninitialized instances. */ vdata.uninitMap = dvmCreateUninitInstanceMap(meth, vdata.insnFlags, vdata.newInstanceCount); if (vdata.uninitMap == NULL) goto bail; /* * Set the \"in try\" flags for all instructions guarded by a \"try\" block. * Also sets the \"branch target\" flag on exception handlers. */ if (!scanTryCatchBlocks(meth, vdata.insnFlags)) goto bail; /* * Perform static instruction verification. Also sets the \"branch * target\" flags. */ if (!verifyInstructions(&amp;vdata)) goto bail; /* * Do code-flow analysis. * * We could probably skip this for a method with no registers, but * that's so rare that there's little point in checking. */ if (!dvmVerifyCodeFlow(&amp;vdata)) &#123; //ALOGD(\"+++ %s failed code flow\", meth-&gt;name); goto bail; &#125;success: result = true;bail: dvmFreeVfyBasicBlocks(&amp;vdata); dvmFreeUninitInstanceMap(vdata.uninitMap); free(vdata.insnFlags); return result;&#125; dvmVerifyClass 具体过程中，会去校验 这个 Class中的所有的 directMethod 方法，和 virtualMethod 方法。具体这些方法包含哪些呢？ 其中时包含了： static 方法 private 方法 构造方法 … … 由此可知： 如果这些方法中直接引用到的类（第一层级关系，不会进行递归搜索） 和 class (源码中的clazz) 在同一个 dex 中的话，这个类就会被打上 CLASS_ISPREVERIFY 标记 PreVerify 缘由 一方面，Dalvik 虚拟机在安装期间，为Class 打上 CLASS_ISPREVERIFIED 是为了提高性能，下次使用时，则会省去校验操作，提高访问效率。 另一方面，被标上“CLASS_ISPREVERIFIED”的类，dvm在运行期载入Class时候，会对其内存中对应的直接引用类进行校验，如果该类存在与直接引用类所在的dex不是同一个，则直接报“pre-verification” 错误，该类无法加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293ClassObject* dvmResolveClass(const ClassObject* referrer, u4 classIdx, bool fromUnverifiedConstant)&#123; DvmDex* pDvmDex = referrer-&gt;pDvmDex; ClassObject* resClass; const char* className; /* * Check the table first -- this gets called from the other \"resolve\" * methods. */ resClass = dvmDexGetResolvedClass(pDvmDex, classIdx); // 预先在dex的缓存表里查 if (resClass != NULL) return resClass; LOGVV(\"--- resolving class %u (referrer=%s cl=%p)\", classIdx, referrer-&gt;descriptor, referrer-&gt;classLoader); /* * Class hasn't been loaded yet, or is in the process of being loaded * and initialized now. Try to get a copy. If we find one, put the * pointer in the DexTypeId. There isn't a race condition here -- * 32-bit writes are guaranteed atomic on all target platforms. Worst * case we have two threads storing the same value. * * If this is an array class, we'll generate it here. */ className = dexStringByTypeIdx(pDvmDex-&gt;pDexFile, classIdx); if (className[0] != '\\0' &amp;&amp; className[1] == '\\0') &#123; /* primitive type */ resClass = dvmFindPrimitiveClass(className[0]); &#125; else &#123; resClass = dvmFindClassNoInit(className, referrer-&gt;classLoader); &#125; if (resClass != NULL) &#123; /* * If the referrer was pre-verified, the resolved class must come * from the same DEX or from a bootstrap class. The pre-verifier * makes assumptions that could be invalidated by a wacky class * loader. (See the notes at the top of oo/Class.c.) * * The verifier does *not* fail a class for using a const-class * or instance-of instruction referring to an unresolveable class, * because the result of the instruction is simply a Class object * or boolean -- there's no need to resolve the class object during * verification. Instance field and virtual method accesses can * break dangerously if we get the wrong class, but const-class and * instance-of are only interesting at execution time. So, if we * we got here as part of executing one of the \"unverified class\" * instructions, we skip the additional check. * * Ditto for class references from annotations and exception * handler lists. */ if (!fromUnverifiedConstant &amp;&amp; IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED)) &#123; ClassObject* resClassCheck = resClass; if (dvmIsArrayClass(resClassCheck)) resClassCheck = resClassCheck-&gt;elementClass; if (referrer-&gt;pDvmDex != resClassCheck-&gt;pDvmDex &amp;&amp; resClassCheck-&gt;classLoader != NULL) // 校验dex是否是安装时的同一个dex &#123; ALOGW(\"Class resolved by unexpected DEX:\" \" %s(%p):%p ref [%s] %s(%p):%p\", referrer-&gt;descriptor, referrer-&gt;classLoader, referrer-&gt;pDvmDex, resClass-&gt;descriptor, resClassCheck-&gt;descriptor, resClassCheck-&gt;classLoader, resClassCheck-&gt;pDvmDex); ALOGW(\"(%s had used a different %s during pre-verification)\", referrer-&gt;descriptor, resClass-&gt;descriptor); dvmThrowIllegalAccessError( \"Class ref in pre-verified class resolved to unexpected \" \"implementation\"); return NULL; &#125; &#125; LOGVV(\"##### +ResolveClass(%s): referrer=%s dex=%p ldr=%p ref=%d\", resClass-&gt;descriptor, referrer-&gt;descriptor, referrer-&gt;pDvmDex, referrer-&gt;classLoader, classIdx); /* * Add what we found to the list so we can skip the class search * next time through. * * TODO: should we be doing this when fromUnverifiedConstant==true? * (see comments at top of oo/Class.c) */ dvmDexSetResolvedClass(pDvmDex, classIdx, resClass); &#125; else &#123; /* not found, exception should be raised */ LOGVV(\"Class not found: %s\", dexStringByTypeIdx(pDvmDex-&gt;pDexFile, classIdx)); assert(dvmCheckException(dvmThreadSelf())); &#125; return resClass;&#125; 实际上，这一步dex的一致性判断，也是google为了防止外部DEX注入的一个安全方案，即保证运行期的Class与其直接引用类之间所在的DEX关系要与安装时候一致 源码链接:http://osxr.org:8080/android/source/dalvik/vm/analysis/DexPrepare.cpphttp://osxr.org:8080/android/source/dalvik/vm/analysis/DexVerify.cpphttp://osxr.org:8080/android/source/dalvik/vm/oo/Resolve.cpp","tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"https://fenglincanyi.github.io/tags/Dalvik/"}]},{"title":"Android 类加载初探","date":"2016-11-17T13:08:00.000Z","path":"2016/11/17/Android 类加载初探/","text":"源码路径(此版本：Android 5.0)：android-5.0.0_r7\\libcore\\dalvik\\src\\main\\java\\dalvik\\system 需要关注的类有： 一、查找类的过程对于一个Class，在Android中，是如何被ClassLoader查找的呢？我们先查看一下，在Android中最原始的ClassLoader: BaseDexClassLoader 中有直接的方法。直接看源码： 再继续追， pathList 的 findClass() 方法： 此时遍历每个dex，通过二进制名来查找类Class；若类未定义或类未找到，则将异常add至suppressed异常集合中，随后抛出。 二、3个类加载器的关系我们先来看看这3个ClassLoader的定义 BaseDexClassLoader DexClassLoader PathClassLoader 由上面可看出：BaseDexClassLoader 继承自最原始的 ClassLoader，DexClassLoader 和 PathClassLoader都继承自BaseClassLoader。依据传入的参数不同，来实现各自不同的 dex 加载功能 ClassLoader 相关说明： 从存储中加载类和资源。 在运行时安装一个或多个类加载器。 每当运行时系统需要在内存中尚不可用的特定类时，都会查询这些类。 通常，类加载器是一个树型结构，其中子类加载器将所有请求委托给父类加载器。 只有父类加载器无法满足请求，子类加载器才会尝试处理它（委托机制） 下面我们再继续分析，传入不同的 optimizedDirectory 参数，两者会有什么样的区别？ DexPathList 构造函数： makeDexElements过程： 加载DexFile，若optimizedDirectory 目录为空，则初始化一个DexFile，否则，直接加载dex文件： 初始化DexFile文件，通常是从一个文件对象中打开一个Dex file ，通常是一个 内容是 classes.dex 的 zip/jar文件，虚拟机将在 /data/dalvik-cache 目录下生成相应名称的文件，且打开它，在系统权限允许的情况下尽可能的先创建或更新该文件不能传递 优化后的 文件名（/data/dalvik-cache），而是在 dexopt 之前的原始状态的文件名。 由上可知，PathClassLoader 的构造函数，与DexClassLoader相比较，optimizedDirectory 优化目录为null。由于optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。optimizedDirectory必须是一个内部存储路径，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory所以DexClassLoader可以通过其他路径（内部存储路径）加载dex，而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。 若想查看相关目录下的dex文件，可参考上一篇文章。","tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://fenglincanyi.github.io/tags/ClassLoader/"}]},{"title":"Android apk安装过程实例分析","date":"2016-11-17T13:08:00.000Z","path":"2016/11/17/Android apk安装过程实例分析/","text":"注：本文不对apk安装之前，系统所做的复杂工作做分析，只针对普通的apk安装过程进行简单的过程理解 一般情况下，在apk安装时，系统一般会显示一个安装界面，获取用户同意之后进行安装，并且有一些apk预处理相关的操作，紧接着，会启动app界面，进入app。在这一过程中，不同版本的Android系统在安装时，对包的处理是不太一样的，以下分Dalivk、ART两种虚拟机进行分析。这里主要采用原生模拟器，进行分析。 一、 Dalvik（JIT：just in time 即时编译） 过程分析： 点击apk包后或apk下载后，安装之前，系统会启动安装界面PackageInstallerActivity，让用户进行授权选择，用户同意后，会调用ApplicationPackageManager 进行相关操作。 调用ApplicationPackageManager，通过IPC来调用 PackageManagerService 中的 installPackage 方法，在这个方法中，又去调用 installPackageAsUser 方法，此时，要进行权限相关校验，完毕之后，会通过 handler 发送消息（类型：INIT_COPY，MCS_BOUND） 然后 startCopy —&gt; handleStartCopy 依次调用，这里，对安装位置、存储空间进行处理，之后会 拷贝apk 相关文件放在相应的目录下。这些文件主要包括： apk文件 jar、so文件 db文件（若有的话） 拷贝完成之后，进行预处理，对于Dalvik来说，dexopt要进行dex文件的优化，生成odex文件，在app运行时，能加快其启动速度。 另外，对于资源处理，是 AssetMananger 来进行资源的解析、加载。 实例考察： 安装时logcat日志：拷贝工作，然后进行dex优化，dexopt执行操作 拷贝后，目录如下： dex位置： 如果把此位置的 dex 删除后，且杀掉已经运行的进程后，再次点击app启动后奔溃，如图： 由此可知，要启动app时，需要加载 /data/dalik-cache 目录下的dex文件 相关参考文献：http://www.woaitqs.cc/android/2016/07/28/android-plugin-get-apk-infohttp://blog.csdn.net/luoshengyang/article/details/8852432 二、ART（AOT：Ahead of time 预编译）Android 4.4之后，对于Android虚拟机又继续做了优化，art 代替了 Dalvik，对于dex文件，优化工作做了改变。 大致的处理过程： 编译时，通过调用 dex2oat 对dex 进行预编译，这个编译器参考了LLVM框架，默认情况下，是采用了quick模式，但在6.0之后，LLVM被彻底去除了。关于LLVM细节，自行Google。 编译后生成的文件 .oat 文件，实际上是Android 私有的ELF文件。在Linux系统中，ELF文件主要分为3类：目标文件（ .o）、共享文件（ .so）、可执行文件。此处Android的 .oat文件属于可执行文件。 oat 文件含有ELF文件正常的结构形态，里面既包含有dex 文件，也包含编译好的本地指令代码。被包含的dex文件也可以是多个。 实例考察 ART 安装apk时，日志记录： 可以看到，有apk的拷贝，有dex2oat的dex优化过程。再追一下相关的目录： 里面有一部分是系统框架层的相关文件。 安装后的目录结构也有变化： 生成相应的平台下的文件，此处我使用的是x86的模拟器 Android 在编译时用到的 dexopt、dex2oat、aapt 都在 /system/bin目录下： 当时对于 multidex 的包也进行了目录查找，如下，留下后续研究做参考。 相关参考文献：https://mssun.me/blog/android-art-runtime-2-dex2oat.htmlhttp://blog.csdn.net/luoshengyang/article/details/39307813","tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"https://fenglincanyi.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"https://fenglincanyi.github.io/tags/ART/"}]},{"title":"RadioGroup、RadioButton动态创建并定制icon显示","date":"2016-10-25T02:24:00.000Z","path":"2016/10/25/RadioGroup、RadioButton动态创建并定制icon显示/","text":"由于原生的Radiobutton不能满足业务需求，所以需要自己定制icon图片，和默认选中某一项。需要自己代码动态实现。废话不多说，上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445private void setViewData() &#123; radioGroup.removeAllViews(); int margin = ScreenUtil.dip2px(this, 14.0f); int marginLeft = ScreenUtil.dip2px(this, 20.0f); int paddingLeft = ScreenUtil.dip2px(this, 3.0f); RadioGroup.LayoutParams layoutParams = new RadioGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); RadioGroup.LayoutParams layoutParams1 = new RadioGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 1); layoutParams.setMargins(marginLeft, margin, margin, margin); layoutParams1.setMargins(margin, 0, margin, 0); int defaultId = -1; for (int i = 0; i &lt; messageList.size(); i++) &#123; RadioButton rb = new RadioButton(this); rb.setMaxLines(2); rb.setPadding(paddingLeft, 0, 0, 0); rb.setText(messageList.get(i).relayMessage); rb.setButtonDrawable(android.R.color.transparent); rb.setTextColor(Color.parseColor(\"#555555\")); rb.setButtonDrawable(null);// 去掉左边默认图标 rb.setCompoundDrawablePadding(margin); rb.setEllipsize(TextUtils.TruncateAt.END);// 结尾处打点显示 Drawable drawable = getResources().getDrawable(R.drawable.relay_message_radio_selector); drawable.setBounds(0, 0, drawable.getMinimumWidth(), drawable.getMinimumHeight()); rb.setCompoundDrawables(drawable, null, null, null); // 手动生成id int generateId = generateViewId(); messages.put(generateId, messageList.get(i).relayMessage); rb.setId(generateId); if (i == 0) &#123; defaultId = generateId; &#125; TextView view = new TextView(this); view.setBackgroundColor(Color.parseColor(\"#dddddd\")); radioGroup.addView(rb, layoutParams); radioGroup.addView(view, layoutParams1); &#125; // 此处：默认选中第一个 radioGroup.check(defaultId); &#125; R.drawable.relay_message_radio_selector 代码如下： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!--设置自己的图片icon--&gt; &lt;item android:drawable=\"@drawable/relay_radio_unchecked\" android:state_checked=\"false\" /&gt; &lt;item android:drawable=\"@drawable/relay_radio_checked\" android:state_checked=\"true\" /&gt;&lt;/selector&gt; 效果如下图：","tags":[{"name":"Radiobutton","slug":"Radiobutton","permalink":"https://fenglincanyi.github.io/tags/Radiobutton/"}]},{"title":"RxJava 初探（一）","date":"2016-10-05T16:45:00.000Z","path":"2016/10/06/RxJava 初探（一）/","text":"一、几个基本概念 由来 Rx(Reactive Extensions)，最初是LINQ的一个扩展，后由微软团队开发，在2012年11月开源。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。 Rx 模式 创建：Rx可以方便的创建事件流和数据流 组合：Rx使用查询式的操作符组合和变换数据流 监听：Rx可以订阅任何可观察的数据流并执行操作 名词定义 Iterable： 可迭代对象，支持以迭代器的形式遍历 Observable：可观察对象，在Rx中定义为更强大的Iterable，在观察者模式中是被观察的对象，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者 Observer： 观察者对象，监听Observable发射的数据并做出响应，Subscriber是它的一个特殊实现 emit：直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法。文章统一翻译为发射 items：直译为项目，条目，在Rx里是指Observable发射的数据项，文章统一译为数据，数据项 二、响应式编程模式 下图采自官方文档，基本阐述了数据流和数据变换的过程： 冷热观察者 热 观察者：可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了） 冷 观察者：一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列 三、操作分类 创建操作： Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, Timer 变换操作：Buffer, FlatMap, GroupBy, Map, Scan和Window 过滤操作：Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, TakeLast 组合操作：And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, Zip 错误处理：Catch和Retry 辅助操作：Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, Using 条件和布尔操作：All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, TakeWhile 算术和集合操作：Average, Concat, Count, Max, Min, Reduce, Sum 转换操作：To 连接操作：Connect, Publish, RefCount, Replay 反压操作：用于增加特殊的流程控制策略的操作符 官方文档翻译版：https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html","tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://fenglincanyi.github.io/tags/RxJava/"}]},{"title":"Gradle相关配置","date":"2016-09-09T02:36:00.000Z","path":"2016/09/09/Gradle相关配置/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091android &#123; compileSdkVersion 24 buildToolsVersion \"24.0.0\" defaultConfig &#123; applicationId \"com.geng.hello\" minSdkVersion 19 targetSdkVersion 24 versionCode 1 versionName \"1.0\" // 在buildConfig.java中自动配置常量字段 buildConfigField('String', \"API_DEBUG_URL\", '\"http://test.baidu.com\"') // 开启multidex,突破64k multiDexEnabled true // ndk cpu架构，生成相应的so包 ndk&#123; abiFilter 'armeabi', 'x86', 'armeabi-v7a', 'x86_64', 'arm64-v8a' &#125; &#125; // 渠道 productFlavors &#123; &#125; signingConfigs &#123; relase &#123; storeFile file(\"relase.keystore\") keyAlias \"relase\" keyPassword \"123456\" storePassword \"123456\" &#125; debug &#123; &#125; &#125; buildTypes &#123; release &#123; // 混淆开启 minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; debug &#123; minifyEnabled false // 4byte对齐，加快解析效率 zipAlignEnabled true // 移除无用的资源文件 shrinkResources true // 更改包名 applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; output.outputFile = new File(output.outputFile.parent, \"debug_\" + buildTime() + \".apk\") &#125; &#125; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:24.0.0'&#125;// --------------------------------gradle.properties配置------------------------------// 加速构建速度org.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.jvmargs=-Xmx2048m// 使用ndk配置android.useDeprecatedNdk=true// 其他：1.查看 keystore 文件的签名信息：在keystore所在目录下，打开cmd:keytool -list -v -keystore keystore文件名再根据提示，输入storepassword即可查看2.混淆：https://segmentfault.com/a/1190000004461614http://www.mayflyask.org/question/247","tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://fenglincanyi.github.io/tags/Gradle/"}]},{"title":"滑动冲突之EditText-ScrollView","date":"2016-08-16T09:14:00.000Z","path":"2016/08/16/滑动冲突之EditText-ScrollView/","text":"问题一EditText的内容过多时，EditText的内容并不能滚动，而是ScrollView的滚动 解决重写EditText的onTouch事件，将触摸事件交给EditText来处理 123456789101112131415et.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; // 设置ScrollView不拦截事件 scrollView.requestDisallowInterceptTouchEvent(true); switch (event.getAction() &amp; MotionEvent.ACTION_MASK)&#123; case MotionEvent.ACTION_UP: // 手指离开时：重置ScrollView事件拦截的状态 scrollView.requestDisallowInterceptTouchEvent(false); break; &#125; return false; &#125; &#125;); &#125; 问题二若有ScrollView内容比较多，比较长时，编辑EditText里的内容时会出现ScrollView滑到底部的现象，使得当前编辑的EditText看不到了 解决修改AndroidManifest.xml中Activity的windowSoftInputMode属性(看具体逻辑而定：adjustPan) 1234&lt;activity android:name=\".me.MineResumeProjectExperienceActivity\" android:screenOrientation=\"portrait android:windowSoftInputMode=\"stateHidden|adjustPan\"/&gt;","tags":[{"name":"滑动冲突","slug":"滑动冲突","permalink":"https://fenglincanyi.github.io/tags/滑动冲突/"}]},{"title":"简单的页面置换算法分析","date":"2016-06-04T11:39:00.000Z","path":"2016/06/04/简单的页面置换算法分析/","text":"本文主要分析操作系统中涉及到的一些常见的置换算法，并不对涉及的操作系统内容过多介绍。这些算法在其他的计算机应用中也有体现，基本原理都是一致的，可参考理解。 一、前提说明本文主要针对一个例子进行说明，以下的算法实现过程均是按照本例进行分析。页面的走向为： 4 3 2 1 4 3 5 4 3 2 1 5 一段程序在内存中，分配3个页面，初始情况下为空。以下依次根据不同的算法进行页面置换过程的分析。 二、算法分析过程1. FIFO（先进先出）FIFO算是最简单、最容易理解的算法了，只要按照依次装入内存的页面的页号按照进入的先后次序排好队列，每次总是从队首出，队尾出。当发生缺页时，置换队首的页面即可。对上面的页面走向序列，分析过程如下图： 2. LRU （最近最少使用 Least Recently Used）在缺页发生时，选择离现在最长时间内，没有被访问过的页面置换出来。分析过程，如下图： 此算法应用的比较广泛，尤其是拿来做缓存算法。Android的API中，已经封装了相关的LRU的算法直接可以调用。 一些图片的缓存算法都是使用LRU进行缓存优化的。ImageLoader框架更是将好几种缓存算法融合到里面，可以灵活选用。详细可以查看源码的实现。3. LFU （最近最不常用 Least Frequently Used）选择访问次数最少的页面置换出来。此算法的实现要花费的开销很大，并且要确定一个合适的周期T也有一定的难度，就不在分析了。3. OPT （理想）此算法置换以后不再需要或最长时间以后才会用到的页面。这一算法一般不可能实现，但它可以作为衡量其他页面置换算法的标准。分析过程，如下图：","tags":[{"name":"LRU","slug":"LRU","permalink":"https://fenglincanyi.github.io/tags/LRU/"}]},{"title":"常见排序算法（C++实现）","date":"2016-05-24T05:55:00.000Z","path":"2016/05/24/常见排序算法（C++实现）/","text":"一、直接插入排序1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;/*直接插入排序稳定的排序算法，时间复杂度：O(n^2)*/void insertSort(int a[], int n)&#123; int temp;//存储要插入的数 int i, j;//j:实际上用来记录位置/*只需要对后面n-1个数排序*/ for (i = 1; i &lt; n; i++)&#123; temp = a[i];// 暂时存储要插入的数 if (a[i] &lt; a[i - 1])&#123; for (j = i - 1; j&gt;=0 &amp;&amp; temp &lt; a[j]; j--)&#123;//遍历前面的数，进行比较，寻找插入的位置 a[j + 1] = a[j];//前面大的数后移 &#125; a[j + 1] = temp;// j是刚好不满足情况的位置，则 j+1 满足该位置 &#125; &#125;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i]&lt;&lt;\" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 3, 2, 43, 12, 90, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); //cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); insertSort(a, n); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 二、折半插入排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;/*折半插入排序：时间复杂度：O(n^2)，稳定对直接插入排序 “初步优化”，寻找插入位置更快*/void binaryInsertSort(int a[], int n) &#123; int temp; int i, j; for (i = 1; i &lt; n; i++) &#123; if (a[i] &lt; a[i - 1]) &#123; temp = a[i]; // “二分法”，寻找插入位置，存储到low int low = 0, high = i - 1, mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (temp &lt; a[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; // 对要插入数之前小的数，整体后移 for (j = i - 1; j &gt;= low; j--) &#123; a[j + 1] = a[j]; &#125; // 最后将刚要插入的数放到找到的位置上 a[low] = temp; &#125; &#125;&#125;/*打印数组*/void print(int a[], int n) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void main() &#123; int a[] = &#123;3, 2, 488, 12, 90, 23&#125;; int n = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); binaryInsertSort(a, n); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 三、希尔排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;/*希尔排序：不稳定的排序对直接插入排序的 “终极优化”，分组进行直接插入排序时间复杂度： O(n^1.3),范围： [O(n^2), O(nlog2(n))]*/void shellSort(int a[],int n)&#123; int d;// 数之间的间隔 int temp;// 存储要插入的数 int i, j; // 先对要排序的数，进行分组,间隔直到1 for (d = n / 2; d &gt;= 1; d /= 2)&#123; // i++,对每个分组交替执行排序，并不是一整个组排完 for (i = d; i &lt; n; i++)&#123;// 也是从该组的第二个数开始，和后面的数比较 temp = a[i]; for (j = i - d; j &gt;= 0 &amp;&amp; temp &lt; a[j]; j -= d)&#123; a[j + d] = a[j]; &#125; a[j + d] = temp; &#125; &#125;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i]&lt;&lt;\" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 13, 0, 43, 12, 1, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); //cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); shellSort(a, n); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 四、冒泡排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;// 提前声明void Swap(int &amp;a, int &amp;b);/*冒泡排序O(n^2)稳定的排序*/void bubbleSort(int a[], int n)&#123; // n-1趟 for (int i = 0; i &lt; n - 1; i++)&#123; for (int j = i; j &lt; n - 1 - i; j++)&#123;// 注意最后两个数 if (a[j]&gt;a[j + 1])&#123; Swap(a[j], a[j + 1]); &#125; &#125; &#125;&#125;/*交换两个数*/void Swap(int &amp;a, int &amp;b)&#123; a = a^b; b = a^b; a = a^b;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 3, 2, 28, 12, 90, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); bubbleSort(a, n); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 五、快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;int partition(int a[], int p, int r);/*快速排序,对冒泡排序的改进,不稳定O(nlog2n),最差情况下：退化为冒泡排序O(n^2)*/void quickSort(int a[], int left,int right)&#123; if (left &lt; right)&#123; // 递归进行排序 int q = partition(a, left, right); quickSort(a, left, q - 1);//左半边 quickSort(a, q + 1, right);//右半边 &#125;&#125;/*选取基准元素key，进行划分*/int partition(int a[], int p, int r)&#123; int i = p; int j = r; int key = a[i]; while (i&lt;j) &#123; while (i &lt; j &amp;&amp; key &lt; a[j])&#123;//右侧扫描 j--; &#125; a[i] = a[j]; while (i &lt; j &amp;&amp; a[i] &lt; key)&#123;//左侧扫描 i++; &#125; a[j] = a[i]; &#125; a[i] = key;//一轮循环完，找到key的位置 return i;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 3, 2, 28, 12, 90, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); quickSort(a, 0, n-1); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 六、选择排序123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace std;void Swap(int &amp;a,int &amp;b);/*简单选择排序稳定时间复杂度：O(n^2)*/void selectionSort(int a[], int n)&#123;// n-1趟，每次选出一个最小的放入有序区 for (int i = 0; i &lt; n - 1; i++)&#123; for (int j = i+1; j &lt; n; j++)&#123; if (a[i]&gt;a[j])&#123; Swap(a[i], a[j]); &#125; &#125; &#125;&#125;/*交换两个数*/void Swap(int &amp;a, int &amp;b)&#123; a = a^b; b = a^b; a = a^b;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 3, 2, 28, 12, 90, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); selectionSort(a, n); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 七、堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;/* 堆排序： 所有情况下：O(nlog2n) 不稳定， 对选择排序的一种改进 （下面采用大根堆方法）*//*交换两个数*/void Swap(int &amp;a, int &amp;b)&#123; a = a^b; b = a^b; a = a^b;&#125;/*堆的筛选算法*/void sift(int a[], int start, int end)&#123; int i = start; for (int j = 2 * i + 1; j &lt;= end; j = 2 * j + 1)&#123;// 重复操作至叶节点 if (j &lt; end &amp;&amp; a[j] &lt; a[j + 1])&#123;// 选出孩子节点最大的，后面来比较 j++; &#125; if (a[i] &gt;= a[j])&#123;// 已经是堆了，不用调整 break; &#125;else&#123; Swap(a[i], a[j]);// 最大孩子上移至根节点 i = j; &#125; &#125;&#125;/*堆排序*/void heapSort(int a[], int n)&#123; for (int i = n / 2; i &gt;= 0; i--)&#123;// 初始建堆，完全二叉树，只需从 n/2 中间节点处开始，向上 sift(a, i, n-1); &#125; for (int i = n - 1; i &gt; 0;i--)&#123;// 根节点和每次最后一个节点交换 Swap(a[0], a[i]); sift(a, 0, i-1); &#125;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 3, 112, 28, 12, 90, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); heapSort(a, n); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125; 八、归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;using namespace std;/*归并排序任何情况下： O(nlog2n)空间复杂度O(n)稳定的排序算法（外排采用）*//*一次归并算法*/void merge(int a[], int start, int mid, int end)&#123; int i = start; int j = mid + 1; int k = 0; int *temp = new int[end - start + 1];//临时存放排好序的数组 while (i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &lt; a[j])&#123; temp[k++] = a[i++]; &#125; else&#123; temp[k++] = a[j++]; &#125; &#125; //处理其中一个没有取完的序列 if (i &lt;= mid)&#123; while (i &lt;= mid)&#123; temp[k++] = a[i++]; &#125; &#125; else&#123; while (j &lt;= end)&#123; temp[k++] = a[j++]; &#125; &#125; // 将临时数组有序数据赋值给原数组 for (i = start,k=0; i &lt;= end; i++,k++)&#123; a[i] = temp[k]; &#125; // 释放内存空间 delete []temp;//此处是数组，必须是[]&#125;/*归并排序递归*/void mergeSort(int arr[], int low, int high)&#123; if (low&lt;high) &#123; int mid = (low + high) / 2; mergeSort(arr, low, mid); mergeSort(arr, mid + 1, high); // 将最后两个有序的序列合并 merge(arr, low, mid, high); &#125;&#125;/*打印数组*/void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int a[] = &#123; 3, 112, 0, 12, 90, 23 &#125;; int n = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"排序前：\" &lt;&lt; endl; print(a, n); mergeSort(a, 0, n - 1); cout &lt;&lt; \"排序后：\" &lt;&lt; endl; print(a, n); system(\"pause\");&#125;","tags":[{"name":"排序","slug":"排序","permalink":"https://fenglincanyi.github.io/tags/排序/"}]},{"title":"Android SingleTask 探究","date":"2016-05-16T03:12:00.000Z","path":"2016/05/16/Android SingleTask 探究/","text":"Android 4种启动模式来说，用法说明此处不再提及主要介绍SingleTop，SingleTask相关的问题 说明 先分析 官方文档 中的一段话： As shown in the table above, standard is the default mode and is appropriate for most types of activities. SingleTop is also a common and useful launch mode for many types of activities. The other modes — singleTask and singleInstance — are not appropriate for most applications, since they result in an interaction model that is likely to be unfamiliar to users and is very different from most other applications. &emsp;&emsp;对于大多数应用来说，SingleTask 和 SingleInstance 并不适用，standrd 和 SingleTop对于普通的大部分Activity启动是适用的。之所以使用singleTask，是存在这样一类问题，想要从后面的Activity 直接跳转到前面某一个Activity时，可能会采用的，如一个应用的MainActivity，LoginActivity等。 &emsp;&emsp;对于SingleTask模式，官方文档的这么一句话，坑了不少人（我还比较幸运，没被坑惨）,也带给我对之前知识的迷惑。 The system creates a new task and instantiates the activity at the root of the new task &emsp;&emsp;其实事实根本不是这样的！！！ 场景复现 下面用代码事实说话：建立3个Activity，分别为Main1Activity、Main2Activity、Main3Activity，前两个都设定单击事件，跳转逻辑为：main1 -&gt; main2 -&gt; main3，其中 Main2Activity 为 SingleTask（AndroidManifest.xml中设置）。打印相应的生命周期方法和所在的 taskId &emsp;&emsp;这些taskid都是一样的，所以它们都是同一个Task中的。事实胜于雄辩。然后搜了一下相关问题，老罗的博客还是给力，彻彻底底的分析了这个坑。致谢老罗的开源精神！&emsp;&emsp;链接：http://blog.csdn.net/luoshengyang/article/details/6714543 同时为了解释项目中类似的一个页面跳转问题，对于上面的demo做了修改： 将 Main1Activity 设置为 SingleTask，其余2个为standrd 操作步骤： 点击图标启动此应用 依次点击进入 Main2，Main3，再点击Home键 点击应用图标重新进入 操作结果：结果再次显示的是Main1Activity，而不是Main3Activity。 先看看打印的日志： 再次点击图标进入应用时，实际上是Main2Activity，Main3Activity 出栈了。分析下这个过程： Main1，Main2，Main3 依次压入栈中，然后 Home 键，则整个Task处于stop状态，是一个background Task。当再次点击应用图标时，系统检测到此时已经存在一个该应用的Task的，此时就将此Background Task 移至前台，成为Foreground Task，而且由于Main1Activity是SingleTask，且位于task底部，所以，再次启动时，将前两个Activity移除，且按照启动顺序依次移除，所以打出的日志是：Main2 desotry，Main3 destory，Main1 onResume。 看来，SingleTask这种特殊的模式引起的Task内Activity的变化是值得注意的 之前我在Stackoverflow上问相关的问题，和我猜想的原因比较类似，链接如下： http://stackoverflow.com/questions/36933755/activity-is-singletask-and-is-root-in-task-restrart-activity-of-top-is-destorye （可供参考） 那么，如何才能在一个新的任务栈里创建新的Activity呢？ 只需要在AndroidManifest.xml中配置即可 在SingleTask的基础之上，再增加设置 taskAffinify 属性即可，默认情况下，taskAffinity属性值为 包名，所以可以自定义一个taskAffinity值，便可以实现一个新的Task,新的Activity处于这个新的Task的root。如，我的 Demo 代码如下： 总结 SingleTask的启动模式并不会启动一个新的任务栈来承载Activity，而是在原来的Task中 SingleTask的启动模式，在官方文档的说明中，日常开发中并不建议使用，SingleInstance更是如此。 Activity的启动模式会带来的Task的变化和Activity的生命周期变化都会在ActivityRecord中体现的，通过源码分析可以发现。 通过以下命令，可以查看Task内的Activity的变化： adb shell dumpsys activity 获取所有应用的activity堆栈信息 adb shell dumpsys activity | grep com.xxx.xxx.xxx 获取某个应用的activity 堆栈信息 adb shell dumpsys activity | grep mFocusedActivity 获取处于栈顶的Activity http://blog.piasy.com/2016/03/19/Android-Task-And-Back-Stack/ (写完此文后，发现有高人已经写得很全面很详尽了)","tags":[{"name":"SingleTask","slug":"SingleTask","permalink":"https://fenglincanyi.github.io/tags/SingleTask/"}]},{"title":"对称、非对称加密技术初探","date":"2016-02-28T09:52:00.000Z","path":"2016/02/28/对称、非对称加密技术初探/","text":"一、对称加密 对称加密简介 对称加密算法所用到的基本的方法是：代换 和 置换。简单来说：（以早期的加密方式举例） 代换：是将明文字母替换成其他字母、数字或符号的方法 对于明文中的每一个字母，用字母表中k个字母来代替（允许循环，即a可以在z的后面） 例如：如果 k = 3，那么明文中的 a 在密文中就变 d ，b 就变成 e。这里 k 值充当密钥 置换：可以说对代换的一种改进，通过并不是通过固定的规则来替换字母，任意字母都可以替换为别的其他字母，但是一一对应的。例如（单表置换加密）： 明文：a b c d e f g 密文：d c h n q i a 以上是早期加密时用的简单的方法，其思想还是通过 替换 来进行加密的 对称加密过程 常见对称加密算法 DES 采用64位的分组长度，和56位的密钥长度，将64位的输入经过一系列的变换得到64位的输出。加密解密使用了相同的密钥。 * 注： 此算法可以被暴力破解，穷举即可解密，所以不再单纯使用 3DES 对DES的改进，使用多个密钥对DES进行三次加密，有些基于Internet的应用已经采纳了这种算法，如：PGP，S/MIME AES(高级加密标准) 对DES的再次改进，性能不低于3DES， 它的密钥长度为128、192或256位，分组长度为128位 Blowfish算法 一种可变密钥长度的分组加密算法，分组长度64位。迄今为止，该算法的安全性还没有受到挑战 RC5算法 参数可变的分组加密算法，此算法使用了三种运算：异或、加、循环 二、非对称加密 基于数学函数的算法，而不再是基于代换和置换技术，公钥加密算法是 非对称的 根据加密算法 和 加密密钥 是推不出 解密密钥的 关于公钥、私钥 正确理解： 公钥是用于 加密 和 认证 的 私钥是用于 解密 和 签名 的 * 这两个密钥，任意一个都可以用来加密，另一个用来解密 * 公钥是公开的 非对称加密过程 RSA简介 第一个能用于数据加密也能用于数字签名的算法，RSA是一种分组密码 易于理解和操作，但安全性一直没有得到理论上的证明 RSA的加密和解密时间是DES的上百倍，效率较低 选取密钥的过程： (1). 选取两个 大质数 p, q. 质数值越大，破解 RSA 就越困难，进行加密和解密的时间就越长 (2). 计算 n = p q, z = (p-1) (q-1) (3). 选取 e &lt; n, 且与 z 互质（e 和 z没有公约数） (4). 找到数 d, 满足 ed - 1 被 z 整除（ ((e * d) - 1) % n) == 0 ） (5). 公钥：（n, e）; 私钥：（n, d） 加密、解密过程： (1). 甲方（发送方）：发送 m (发送数)，m &lt; n, (2). 发送时，用乙方（接收方）的公钥加密：密文 c = m^e % n (3). 乙方：解密用自己的私钥，得到明文 m = c^d % n 其他非对称加密算法 ElGamal算法：基于公钥密码体制和椭圆曲线加密体系，既能用于数据加密，又能用于数字签名 背包加密算法：基于背包算法，但是大多数一次背包体制均被破译了，因此很少有人使用它 散列(哈希)函数 是公开的函数，可以将任意长的串映射成一个固定长度的串，Hash值 由下面的函数 H 生成： h = H (M) M: 变长的消息，H(M)是定长的 Hash值 常见的散列函数有： MD5，SHA-1 MD5： 有广泛的应用，如在 Java API 中就有体现，但也不安全，有人专门将大量的明文和密文收集起来存至数据库中，用于暴力破解MD5。所以实际使用时，需 “加盐” SHA-1: 在Linux系统、Git中都有广泛的使用，它的原理类似于 MD4(MD5的前身)。 说明： MD5 和 SHA-1被好多人称为 加密算法，其实这两个散列函数，是用于散列获得消息摘要的，严格来说，应该叫做 消息摘要算法 数字签名 签名是用来验证 发送方的身份 和 数据的完整性(数据是否被第三方篡改)的 签名分为： 普通数字签名（如：RSA，DES） 特殊数字签名（如：有盲签名，代理签名） 数字签名过程： (1). 发送方 生成一对公钥和私钥，将自己的 公钥 发送给 接收方 (2). 发送方 将 要发送的消息 msg, 进行散列(MD5或者SHA-1)，得到 消息摘要 (3). 发送方 将 消息摘要 用自己的私钥加密，加密后的信息就是 数字签名 (4). 发送方 将 数字签名 附在 要发送的消息 msg’ (是通过接收方的公钥加密后的) 的后面，再一起发送至 接收方数字签名的验证过程： (1). 接收方 收到消息后，对消息 msg’ 使用自己的私钥进行解密得到 msg (2). 接收方 对 数字签名 使用 发送方的公钥解密，得到 消息摘要(之前是由消息经过散列得到) (3). 接收方 使用相同的 散列函数(散列函数也是公开的)对 msg 进行散列，再计算得到一个 消息摘要 (4). 接收方 对比着两个 消息摘要 即可判断出 消息的完整性 身份的正确性：可通过 使用公钥能否解开数字签名 来判断 数据的完整性：可通过 对比两个消息摘要是否相同 来判断","tags":[{"name":"加密","slug":"加密","permalink":"https://fenglincanyi.github.io/tags/加密/"},{"name":"签名","slug":"签名","permalink":"https://fenglincanyi.github.io/tags/签名/"}]},{"title":"Git学习笔记（二）","date":"2016-02-19T08:06:00.000Z","path":"2016/02/19/Git学习笔记（二）/","text":"常用命令： 1、初始 git &lt;verb&gt; --help 查看命令用法(方法之一) git init 初始化git仓库(在当前目录下会创建.git目录) 2、 远程操作 git clone URL 从远程clone git仓库 git remote -v 查看远程仓库使用的 Git 保存的简写与其对应的 URL git pull URL 将数据拉取到你的本地仓库,并合并远程分支到当前分支 git fetch URL 将数据拉取到你的本地仓库,并不会自动合并或修改你当前的工作 git push URL 将本地git仓库推送到远程仓库(一次就记住URL了,之后不需要写URL) 3、添加文件 git add filename 添加某个文件(该文件处于已跟踪(A)：tracked) git add --all , -A 添加所有文件 4、提交文件 git commit -m &quot;提交信息&quot; 提交当下工作区的文件 git commit -a -m &quot;提交信息&quot; 前两个命令的合并，直接跳过暂存区提交 git commit 启动文本编辑器写提交信息 5、查看文件状态 git status 查看当前文件状态 git status -s 查看当前文件详细状态列表 6、查看日志 git log 查看提交的日志 git log --oneline 查看提交的日志简略信息 git log -p -2 查看最近两次提交的日志 7、查看修改 git diff 查看未暂存文件(未add)的修改内容 git diff --staged, --cached 查看已暂存文件(已add)的修改内容 8、删除文件 git rm filename 移除文件 git rm --cached filename 移除文件,但该文件还留在工作区，但之后不会被跟踪(untracked) git rm \\*.txt 移除以 .txt 结尾的文件 9、更改文件名 git mv oldName newName 更改文件名 10、标签操作 git tag -a v1.0 -m &quot;info&quot; 打标签 v1.0:版本号，info:版本信息 git tag 查看已有标签 11、分支操作 git branch branchName 创建分支 git branch -d branchName 删除分支 git checkout branchName 切换分支 git merge branchName 合并分支到当前分支 git mergetool 启动图形化工具解决冲突 git branch 查看所有分支 git branch -v, -vv 查看所有分支的最后一次提交 补充： rebase: 变基，另一种不同于merge的”整合”方式 (命令示例：git rebase master) 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 请注意： 无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 准则： 不要对在你的仓库外有副本的分支执行变基 只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作","tags":[{"name":"Git","slug":"Git","permalink":"https://fenglincanyi.github.io/tags/Git/"}]},{"title":"Git学习笔记（一）","date":"2016-02-19T07:28:00.000Z","path":"2016/02/19/Git学习笔记（一）/","text":"一、Git特点1. 直接记录快照，而非差异比较 在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。2. 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。3. Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。SHA-1 哈希看起来是这样： &gt;24b9da6552252987aa493b52f8696cd6d3b00373 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 4. Git 一般只添加数据 你执行的 Git 操作，几乎只往 Git 数据库中增加数据 二、Git 中的文件有3种状态：1. 已提交：数据已经安全的保存在本地数据库中2. 已修改：修改了文件，但未保存到数据库中3. 已暂存：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 三、Git 中的3个工作区域1. Git仓库：保存项目的元数据和对象数据库，Git中最重要的部分，供其他人clone 仓库2. 工作目录：对项目的某个版本独立提取出来的，供工作中使用、修改 工作目录下的文件状态： 已跟踪：纳入了版本控制的文件，后期可能处于 未修改，已修改或放入暂存区了 未跟踪：工作目录下除已跟踪文件外的其他所有文件 3. 暂存区：是一个文件，保存下次将提交的文件列表信息，一般在Git仓库目录中，有时也被叫做索引 四、Git 的基本工作流程1. 在工作目录中修改文件2. 暂存文件，将文件的快照放入暂存区3. 提交更新，找到暂存区的文件，将快照永久性存储到Git仓库中五、Git 个人信息初始配置 全局信息配置：(个人默认信息) git config –global user.name “xxx” git config –global user.email xxx@qq.coom 此配置会写入 user目录下的 .gitconfig文件，实际上为个人信息默认值 临时配置： 去掉 –global 即可 实际是在其配置列表中追加其信息，重复变量名，不同的value值 (Git每次会读取不同文件，其中就可能含有同一个配置) Git 会使用每个变量的最后一次的配置的值","tags":[{"name":"Git","slug":"Git","permalink":"https://fenglincanyi.github.io/tags/Git/"}]},{"title":"Android Studio NDK开发环境搭建及Demo示例","date":"2016-01-16T11:34:00.000Z","path":"2016/01/16/Android Studio NDK开发环境搭建及Demo示例/","text":"说明：Android Studio 1.4后支持C/C++开发，1.3之前的版本坑点较多，所以使用1.4后的版本较为容易 所用工具版本 Android Studio 1.5 android-ndk-r10e-windows-x86_64.exe 配置NDK环境 自行下载 ndk 工具，在你的要安装 ndk 的目录下，直接双击 此安装包，就会自动安装至此目录下，过程中会打开cmd窗口，命令行不断执行命令，需等待一会即可 cmd窗口自动关闭后，会出现 ndk 的文件夹，如图： 配置ndk环境变量，path 中添加即可，如我的路径如下： PATH： D:\\android-ndk-r10e 保存后，打开cmd,输入命令: ndk-build 出现如下显示，则安装成功： 第一个NDKDemo studio中，新建一个project， name： NDKDemo 在本项目中，配置 ndk 路径，如图： 点击OK， 此时，等待gradle构建，构建完成后，观察 local.properties 文件，多出来了 ndk 的路径，如图所示： 打开 grade.properties 文件，在末尾添加： android.useDeprecatedNdk=”true” * 此步骤，为了防止下一步修改 app/build.gradle 文件后报错 打开 app/build.gradle 文件，在 defaultConfig 下加入ndk相关配置参数： 123ndk &#123; moduleName \"HelloNDK\"&#125; * 此处的 modleName 是 加载库文件的标识，必须和后面代码中的 System.loadLibrary(&quot;HelloNDK&quot;) 保持一致，否则会报错 书写 native 方法 和 加载类库，代码如下： 1234567static &#123; // 加载类库 System.loadLibrary(\"HelloNDK\");&#125;// native方法 调用 C代码public native String javaCallC(); 如图，我这是后续的图片，过程中的未截： 打开左下角的 Terminal，cd 至 java 路径下，并执行命令： javah -d jni [native方法所在类的全路径] 如图： 在studio中：类的全路径可 通过 右击该类 -&gt; Copy Reference获得，执行成功后，刷新下目录，可看到目录中多了一个 咖啡色的jni目录，和一个 .h文件，如图： 右击 Main目录的图标 -&gt; New -&gt; Floder -&gt; JNI Floder，之后会出现一个 蓝色的JNI 文件夹，如图： 此时，继续解决上面 native 方法名报错（红色）的问题，Alt + Enter 选择创建 .c 中的方法，这时，会在蓝色的JNI文件夹下自动生成一个 .c 文件，并且 含有 c代码，里面有复杂的方法头 * 可能 native 方法名仍然是红色的，这可能是 Studio 的一个bug，但其实是可以运行的。可能过一段时间红色会消失变为正常，我的就是这种情况 下面就可以书写真正的 C代码了，此处 只简单写下，关于更牛逼的用法，将更新在后面blog中，继续总结。 此处代码改为： 1return (*env)-&gt;NewStringUTF(env, \"你好，NDK\"); OK，第一个NDK Demo可以运行了，上图： 总结 相比以前在 eclipse 中进行 NDK 开发，studio中显得方便多了，并不用安装 CDT 和 cygwin，而且 .c 文件及其内容可以自动生成 利用命令 javah -d jni [native方法所在类的全路径] 生成的 .h头文件 可以在 有了 .c 文件后删除，此 .h 文件主要是用来用于生成 .c 文件中相应比较长的方法头。如果之前没有 .h 文件，Alt + Enter 是无法自动生成 .c文件的 必须在 有 /src/main/jni 的文件夹（蓝色的jni文件夹）下，才能自动生成.c 文件 .c 文件中要出现了中文，必须是 UTF-8 下，否则，运行时会崩溃报错 注意观察 /app/build/intermediates/ndk 目录下，有相关的 所有平台的 .so 文件（默认情况下，生成所有平台的；若只想生成某几种平台的，可在 app/build.gradle（abi-Filters “armeabi”,”armeabi-v7a”,”x86”） 中 或者 Android.mk中 进行配置） 补充 so文件和native类与混淆无关，无需keep语句 实现类一定要方法名正确否则会报java.lang.UnsatisfiedLinkError: dlopen failed异常 studio工具的提示并不是很智能，所以有时要rebuild project","tags":[{"name":"JNI","slug":"JNI","permalink":"https://fenglincanyi.github.io/tags/JNI/"},{"name":"NDK","slug":"NDK","permalink":"https://fenglincanyi.github.io/tags/NDK/"}]}]