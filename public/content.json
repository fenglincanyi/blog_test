[{"title":"instant run 相关分析","date":"2016-12-17T05:00:00.000Z","path":"2016/12/17/instant run 相关分析/","text":"Android Studio 2.0 引入了即时编译功能：instant run，一定程度上进行了增量编译、增量更新代码，节省了开发耗时（喝咖啡的时间）。下面具体分析下instant run相关工作流程和相关的源码 instant run 使用版本要求Gradle 2.0 以上build.gradle：minSdkVersion 15 以上（设置21以上可获得最佳性能）Android 5.0以上的手机或模拟器 使用首先确认开启instant run，在settings中搜索instant run，可看到相关设置，默认instant run功能是开启的 当第一次点击 run 按钮 ，进行第一次编译打包。apk成功安装之后，再观察工具栏，run按钮发生了变化： 然后我们随意修改一部分代码，点击运行，可看到手机屏幕上弹出toast，提示代码已经改变了，可看到最新的运行效果。使用起来也比较方便、快捷。 更新方式 热交换 hot swap更改现有方法的实现代码；不会重新初始化正在运行的app，不要做重启app，activity的操作，即可看到最新代码运行结果 温交换 warm swap更改或移除当前的资源；activity会自动重启（小闪烁），即可看到最新运行结果 冷交换 cold swap对代码有结构性的更改（字段更改、类继承关系、清单文件更改）；此时会重启app 参考：https://developer.android.com/studio/run/index.html?hl=zh-cnhttps://medium.com/google-developers/instant-run-how-does-it-work-294a1633367f#.go1u6yq2o 过程分析第一次打包instant run 第一次编译打包流程，会执行下面的工作 先来看看生成的apk： 多出了 instant-run.zip文件，那它里面是什么内容呢？ instant-run.zip里的dex文件，是我们真正的业务代码 那instant run 相关的类呢，反而跑到了外层的classes.dex和classes2.dex中。 实际上这2个dex中的内容是instant-run.jar和instant-run-bootstrap.jar 的内容（自己可反编译出来看看）： 就是说，第一次运行打包时候，是将 instant-run.jar 和 instant-run-bootstrap.jar 2个jar 变成 2个dex文件，真正的业务代码编译后整合到别的dex中，然后放在了instant-run.zip中 classes.dex -&gt; instant-run.jar &nbsp;&nbsp;&nbsp;&nbsp; instant run 相关api类classes2.dex -&gt; instant-run-bootstrap.jar &nbsp;&nbsp; AppInfo.class 再来看看清单文件，application 被替换成 BootstrapApplication： instant run 代码分析attachBaseContext() 中执行的三个步骤首先来观察下该类下的 attachBaseContext()方法，其中做了3个比较重要的事情：createResources() 、setupClassLoaders()、createRealApplication() createResources()主要是判断资源resource.ap是否改变，然后保存resource.ap的路径到externalResourcePath中 setupClassLoaders()设置instant run 相关的classLoader，及其继承关系（PathClassLoader -&gt; BootClassLoader 变为 PathClassLoader -&gt; IncrementalClassLoader -&gt; BootClassLoader） createRealApplication()进行application 的相关替换，当前app的application变为realApplication；反射的方式拿到 真实的 Application，通过AppInfo相关字段进行获取 下面我们分析一下setClassLoader详细过程：主要经历了以下的方法： 这几个ClassLoader类定义的逻辑关系如下： findClass过程依次委托给 父ClassLoader，最后是让PathClassLoader去加载类 onCreate() 过程 通过MonkeyPatcher 替换当前的 application 为 realApplication包含ActivityThread中相应的Application 都替换成 realApplication 替换相应的资源resource替换当前app的assetManager，资源相关的变量等等（期间都是用反射的方式） Server 创建，建立Socket连接，开启连接 Server 部署工作在Server 建立起连接后，三种部署工作（hot swap、warm swap、cold swap），都是通过Server进行操作。具体在那种情形下进行哪种交换，源码中有具体实现： 12345678910111213141516171819202122232425262728293031323334private int handlePatches(List&lt;ApplicationPatch&gt; paramList, boolean paramBoolean, int paramInt) &#123; if (paramBoolean) &#123; FileManager.startUpdate(); &#125; Iterator localIterator = paramList.iterator(); while (localIterator.hasNext()) &#123; Object localObject = (ApplicationPatch) localIterator.next(); String str = ((ApplicationPatch) localObject).getPath(); if (str.endsWith(&quot;.dex&quot;)) &#123;// 冷交换 handleColdSwapPatch((ApplicationPatch) localObject); int j = 0; localObject = paramList.iterator(); do &#123; i = j; if (!((Iterator) localObject).hasNext()) &#123; break; &#125; &#125; while (!((ApplicationPatch) ((Iterator) localObject).next()).getPath().equals(&quot;classes.dex.3&quot;)); int i = 1; if (i == 0) &#123; paramInt = 3; &#125; &#125; else if (str.equals(&quot;classes.dex.3&quot;)) &#123;// 热交换 paramInt = handleHotSwapPatch(paramInt, (ApplicationPatch) localObject); &#125; else if (isResourcePath(str)) &#123;// 资源：温交换 paramInt = handleResourcePatch(paramInt, (ApplicationPatch) localObject, str); &#125; &#125; if (paramBoolean) &#123; FileManager.finishUpdate(true); &#125; return paramInt;&#125; 代码热更新流程在我们增加一行代码后，点击运行，我们来观察生成的类的变化在 build 目录下，transforms 中有生成相关的代码 几个重要类我们来具体看看demo 中代码更改：MainActivity$override类内容的确是最新的代码内容 AppPatchesLoaderImpl类记录了更改的类，存储在一个数组中，供类加载时候，替换成最新的类的代码内容 在此处，我反编译了slice_0-classes.dex： 第一次运行打包生成的 “业务代码” 中，生成的类中的方法里都增加了 IncrementalChange 相关的判断，如果 $change 不为空，说明我们有更改的代码，有更改的代码，则执行最新更改的代码 12345678910111213141516171819public Object access$dispatch(String paramString, Object... paramVarArgs) &#123; switch (paramString.hashCode()) &#123; case -833446436: initView((MainActivity) paramVarArgs[0]); return null; case -641568046: onCreate((MainActivity) paramVarArgs[0], (Bundle) paramVarArgs[1]); return null; case -399296056: return init$args((MainActivity[]) paramVarArgs[0], (Object[]) paramVarArgs[1]); case 781336394: init$body((MainActivity) paramVarArgs[0], (Object[]) paramVarArgs[1]); return null; case 2118315029: testClick((MainActivity) paramVarArgs[0], (View) paramVarArgs[1]); return null; &#125; throw new InstantReloadException(String.format(&quot;String switch could not find &apos;%s&apos; with hashcode %s in %s&quot;, new Object[]&#123;paramString, Integer.valueOf(paramString.hashCode()), &quot;com/geng/myapplication/MainActivity&quot;&#125;)); &#125; 最后根据不同的类型，进行相关的重启（activity 或者 app），主要由 Restarter负责，同时也提供了相关的重启方法： restartActivity() restartApp() 至此，整个 instant run 的分析告一段落，需要慢慢消化一下。。。 源码及工具资源：https://github.com/fenglincanyi/Study/tree/master/instant%20run%E7%9B%B8%E5%85%B3参考：https://github.com/nuptboyzhb/AndroidInstantRun","tags":[{"name":"instant run","slug":"instant-run","permalink":"https://fenglincanyi.github.io/tags/instant-run/"}]},{"title":"Android WebView 相关踩坑","date":"2016-12-15T05:29:00.000Z","path":"2016/12/15/Android WebView 相关踩坑/","text":"url 传参 url 嵌套的问题问题场景get请求链接中： 传参中含有url “chinahr://customer/h5page?” + LEOGAO_PAGE+”=”+finishpage+”&amp;”+LEOGAO_ACTION+”=”+finishaction + “&amp;”+INTENT_URL+”=” + url 其中：url： file:///android_asset/hybird/cp/index.html?uid=” + cuid +”&amp;gender=”+gender +”&amp;photo=”+photoPath; 合并之后：“chinahr://customer/h5page?” + LEOGAO_PAGE+”=”+finishpage+”&amp;”+LEOGAO_ACTION+”=”+finishaction + “&amp;”+INTENT_URL+”=”+“file:///android_asset/hybird/cp/index.html?uid=” + cuid +”&amp;gender=”+gender +”&amp;photo=”+photoPath； 所以这个 url 中的 第二个及以后的参数第一次就会被router解析，并不会将 url 整体作为一个参数传到下一个页面中去再次解析识别。 解决方法Android端1234567891011JSONObject jsonObject = new JSONObject();try &#123; jsonObject.put(&quot;uid&quot;, cUid); jsonObject.put(&quot;gender&quot;, gender); jsonObject.put(&quot;photo&quot;, potoPath); paramsResult = URLEncoder.encode(Base64.encodeToString(jsonObject.toString().getBytes(), Base64.DEFAULT));&#125; catch (JSONException e) &#123; e.printStackTrace();&#125;// 此处为加载本地，也可以为网络urlBaseH5Activity.startWebViewActivity(this, &quot;file:///android_asset/hybird/cp/index.html?params=&quot; + paramsResult, &quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); 前端js12345678var me = this;var href = window.location.url || window.location.href;var params = me.getParams(href, &apos;params&apos;);params = Base64.decode(decodeURIComponent(params));info = JSON.parse(params);var uid = info.uid;var photo = info.photo;var gender = info.gender; 踩坑 第一次使用UrlEncoder编码，k可能会造成浏览器与js解析数据会存在不一致的问题解决：先使用base64进行编码，解决数据不一致的问题，再进行UrlEncoder编码（为了防止base64编码后的数据解析时：”+” 会当做空格的问题 ） 加载本地 html 时：直接设置 cookie 在 本地url 上是无效的，也是没有必要的。自己遇到的问题是：加载本地 html，此html中使用的 jsonp 请求网络，此时需要的cookie，需要设置 WebView 的cookie，使之持久化，下次会自动带 cookie 访问网络的。 Android 5.0 WebView 设置cookie问题 对于 Android 5.0 以上的WebView，默认关闭了接收三方cookie，但是提供了设置 cookie的接口，需要开发者去手动设置三方信任cookie。否则，加载本地 html 时，cookie 同步不过去。代码如下： 123456CookieManager cookieManager = CookieManager.getInstance();cookieManager.setAcceptCookie(true);cookieManager.setAcceptFileSchemeCookies(true);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.setAcceptThirdPartyCookies(webView, true);&#125; Android WebView 加载本地 html webview 加载 sd 卡下的 html 是不能访问的，权限问题。 如果访问 /data/data/包名/files/index.html，需要开启文件访问权限（默认是开启的，不要动态设置关闭）1webSettings.setAllowFileAccess(false);// 关闭 补充在线加解密、编码解析工具：http://tool.oschina.net/encrypt?type=3","tags":[{"name":"h5","slug":"h5","permalink":"https://fenglincanyi.github.io/tags/h5/"}]},{"title":"Android apk安装过程实例分析","date":"2016-11-17T13:08:00.000Z","path":"2016/11/17/Android apk安装过程实例分析/","text":"注：本文不对apk安装之前，系统所做的复杂工作做分析，只针对普通的apk安装过程进行简单的过程理解 一般情况下，在apk安装时，系统一般会显示一个安装界面，获取用户同意之后进行安装，并且有一些apk预处理相关的操作，紧接着，会启动app界面，进入app。在这一过程中，不同版本的Android系统在安装时，对包的处理是不太一样的，以下分Dalivk、ART两种虚拟机进行分析。这里主要采用原生模拟器，进行分析。 一、 Dalvik（JIT：just in time 即时编译） 过程分析： 点击apk包后或apk下载后，安装之前，系统会启动安装界面PackageInstallerActivity，让用户进行授权选择，用户同意后，会调用ApplicationPackageManager 进行相关操作。 调用ApplicationPackageManager，通过IPC来调用 PackageManagerService 中的 installPackage 方法，在这个方法中，又去调用 installPackageAsUser 方法，此时，要进行权限相关校验，完毕之后，会通过 handler 发送消息（类型：INIT_COPY，MCS_BOUND） 然后 startCopy —&gt; handleStartCopy 依次调用，这里，对安装位置、存储空间进行处理，之后会 拷贝apk 相关文件放在相应的目录下。这些文件主要包括： apk文件 jar、so文件 db文件（若有的话） 拷贝完成之后，进行预处理，对于Dalvik来说，dexopt要进行dex文件的优化，生成odex文件，在app运行时，能加快其启动速度。 另外，对于资源处理，是 AssetMananger 来进行资源的解析、加载。 实例考察： 安装时logcat日志：拷贝工作，然后进行dex优化，dexopt执行操作 拷贝后，目录如下： dex位置： 如果把此位置的 dex 删除后，且杀掉已经运行的进程后，再次点击app启动后奔溃，如图： 由此可知，要启动app时，需要加载 /data/dalik-cache 目录下的dex文件 相关参考文献：http://www.woaitqs.cc/android/2016/07/28/android-plugin-get-apk-infohttp://blog.csdn.net/luoshengyang/article/details/8852432 二、ART（AOT：Ahead of time 预编译）Android 4.4之后，对于Android虚拟机又继续做了优化，art 代替了 Dalvik，对于dex文件，优化工作做了改变。 大致的处理过程： 编译时，通过调用 dex2oat 对dex 进行预编译，这个编译器参考了LLVM框架，默认情况下，是采用了quick模式，但在6.0之后，LLVM被彻底去除了。关于LLVM细节，自行Google。 编译后生成的文件 .oat 文件，实际上是Android 私有的ELF文件。在Linux系统中，ELF文件主要分为3类：目标文件（ .o）、共享文件（ .so）、可执行文件。此处Android的 .oat文件属于可执行文件。 oat 文件含有ELF文件正常的结构形态，里面既包含有dex 文件，也包含编译好的本地指令代码。被包含的dex文件也可以是多个。 实例考察 ART 安装apk时，日志记录： 可以看到，有apk的拷贝，有dex2oat的dex优化过程。再追一下相关的目录： 里面有一部分是系统框架层的相关文件。 安装后的目录结构也有变化： 生成相应的平台下的文件，此处我使用的是x86的模拟器 Android 在编译时用到的 dexopt、dex2oat、aapt 都在 /system/bin目录下： 当时对于 multidex 的包也进行了目录查找，如下，留下后续研究做参考。 相关参考文献：https://mssun.me/blog/android-art-runtime-2-dex2oat.htmlhttp://blog.csdn.net/luoshengyang/article/details/39307813","tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"https://fenglincanyi.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"https://fenglincanyi.github.io/tags/ART/"}]},{"title":"Android 类加载初探","date":"2016-11-17T13:08:00.000Z","path":"2016/11/17/Android 类加载初探/","text":"源码路径(此版本：Android 5.0)：android-5.0.0_r7\\libcore\\dalvik\\src\\main\\java\\dalvik\\system 需要关注的类有： 一、查找类的过程对于一个Class，在Android中，是如何被ClassLoader查找的呢？我们先查看一下，在Android中最原始的ClassLoader: BaseDexClassLoader 中有直接的方法。直接看源码： 再继续追， pathList 的 findClass() 方法： 此时遍历每个dex，通过二进制名来查找类Class；若类未定义或类未找到，则将异常add至suppressed异常集合中，随后抛出。 二、3个类加载器的关系我们先来看看这3个ClassLoader的定义 BaseDexClassLoader DexClassLoader PathClassLoader 由上面可看出：BaseDexClassLoader 继承自最原始的 ClassLoader，DexClassLoader 和 PathClassLoader都继承自BaseClassLoader。依据传入的参数不同，来实现各自不同的 dex 加载功能 ClassLoader 相关说明： 从存储中加载类和资源。 在运行时安装一个或多个类加载器。 每当运行时系统需要在内存中尚不可用的特定类时，都会查询这些类。 通常，类加载器是一个树型结构，其中子类加载器将所有请求委托给父类加载器。 只有父类加载器无法满足请求，子类加载器才会尝试处理它（委托机制） 下面我们再继续分析，传入不同的 optimizedDirectory 参数，两者会有什么样的区别？ DexPathList 构造函数： makeDexElements过程： 加载DexFile，若optimizedDirectory 目录为空，则初始化一个DexFile，否则，直接加载dex文件： 初始化DexFile文件，通常是从一个文件对象中打开一个Dex file ，通常是一个 内容是 classes.dex 的 zip/jar文件，虚拟机将在 /data/dalvik-cache 目录下生成相应名称的文件，且打开它，在系统权限允许的情况下尽可能的先创建或更新该文件不能传递 优化后的 文件名（/data/dalvik-cache），而是在 dexopt 之前的原始状态的文件名。 由上可知，PathClassLoader 的构造函数，与DexClassLoader相比较，optimizedDirectory 优化目录为null。由于optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。optimizedDirectory必须是一个内部存储路径，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory所以DexClassLoader可以通过其他路径（内部存储路径）加载dex，而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。 若想查看相关目录下的dex文件，可参考上一篇文章。","tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://fenglincanyi.github.io/tags/ClassLoader/"}]},{"title":"RadioGroup、RadioButton动态创建并定制icon显示","date":"2016-10-25T02:24:00.000Z","path":"2016/10/25/RadioGroup、RadioButton动态创建并定制icon显示/","text":"由于原生的Radiobutton不能满足业务需求，所以需要自己定制icon图片，和默认选中某一项。需要自己代码动态实现。废话不多说，上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445private void setViewData() &#123; radioGroup.removeAllViews(); int margin = ScreenUtil.dip2px(this, 14.0f); int marginLeft = ScreenUtil.dip2px(this, 20.0f); int paddingLeft = ScreenUtil.dip2px(this, 3.0f); RadioGroup.LayoutParams layoutParams = new RadioGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); RadioGroup.LayoutParams layoutParams1 = new RadioGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 1); layoutParams.setMargins(marginLeft, margin, margin, margin); layoutParams1.setMargins(margin, 0, margin, 0); int defaultId = -1; for (int i = 0; i &lt; messageList.size(); i++) &#123; RadioButton rb = new RadioButton(this); rb.setMaxLines(2); rb.setPadding(paddingLeft, 0, 0, 0); rb.setText(messageList.get(i).relayMessage); rb.setButtonDrawable(android.R.color.transparent); rb.setTextColor(Color.parseColor(&quot;#555555&quot;)); rb.setButtonDrawable(null);// 去掉左边默认图标 rb.setCompoundDrawablePadding(margin); rb.setEllipsize(TextUtils.TruncateAt.END);// 结尾处打点显示 Drawable drawable = getResources().getDrawable(R.drawable.relay_message_radio_selector); drawable.setBounds(0, 0, drawable.getMinimumWidth(), drawable.getMinimumHeight()); rb.setCompoundDrawables(drawable, null, null, null); // 手动生成id int generateId = generateViewId(); messages.put(generateId, messageList.get(i).relayMessage); rb.setId(generateId); if (i == 0) &#123; defaultId = generateId; &#125; TextView view = new TextView(this); view.setBackgroundColor(Color.parseColor(&quot;#dddddd&quot;)); radioGroup.addView(rb, layoutParams); radioGroup.addView(view, layoutParams1); &#125; // 此处：默认选中第一个 radioGroup.check(defaultId); &#125; R.drawable.relay_message_radio_selector 代码如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--设置自己的图片icon--&gt; &lt;item android:drawable=&quot;@drawable/relay_radio_unchecked&quot; android:state_checked=&quot;false&quot; /&gt; &lt;item android:drawable=&quot;@drawable/relay_radio_checked&quot; android:state_checked=&quot;true&quot; /&gt;&lt;/selector&gt; 效果如下图：","tags":[{"name":"Radiobutton","slug":"Radiobutton","permalink":"https://fenglincanyi.github.io/tags/Radiobutton/"}]},{"title":"RxJava 初探（一）","date":"2016-10-05T16:45:00.000Z","path":"2016/10/06/RxJava 初探（一）/","text":"一、几个基本概念 由来 Rx(Reactive Extensions)，最初是LINQ的一个扩展，后由微软团队开发，在2012年11月开源。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。 Rx 模式 创建：Rx可以方便的创建事件流和数据流 组合：Rx使用查询式的操作符组合和变换数据流 监听：Rx可以订阅任何可观察的数据流并执行操作 名词定义 Iterable： 可迭代对象，支持以迭代器的形式遍历 Observable：可观察对象，在Rx中定义为更强大的Iterable，在观察者模式中是被观察的对象，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者 Observer： 观察者对象，监听Observable发射的数据并做出响应，Subscriber是它的一个特殊实现 emit：直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法。文章统一翻译为发射 items：直译为项目，条目，在Rx里是指Observable发射的数据项，文章统一译为数据，数据项 二、响应式编程模式 下图采自官方文档，基本阐述了数据流和数据变换的过程： 冷热观察者 热 观察者：可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了） 冷 观察者：一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列 三、操作分类 创建操作： Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, Timer 变换操作：Buffer, FlatMap, GroupBy, Map, Scan和Window 过滤操作：Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, TakeLast 组合操作：And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, Zip 错误处理：Catch和Retry 辅助操作：Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, Using 条件和布尔操作：All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, TakeWhile 算术和集合操作：Average, Concat, Count, Max, Min, Reduce, Sum 转换操作：To 连接操作：Connect, Publish, RefCount, Replay 反压操作：用于增加特殊的流程控制策略的操作符 官方文档翻译版：https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html","tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://fenglincanyi.github.io/tags/RxJava/"}]},{"title":"Gradle相关配置","date":"2016-09-09T02:36:00.000Z","path":"2016/09/09/Gradle相关配置/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091android &#123; compileSdkVersion 24 buildToolsVersion &quot;24.0.0&quot; defaultConfig &#123; applicationId &quot;com.geng.hello&quot; minSdkVersion 19 targetSdkVersion 24 versionCode 1 versionName &quot;1.0&quot; // 在buildConfig.java中自动配置常量字段 buildConfigField(&apos;String&apos;, &quot;API_DEBUG_URL&quot;, &apos;&quot;http://test.baidu.com&quot;&apos;) // 开启multidex,突破64k multiDexEnabled true // ndk cpu架构，生成相应的so包 ndk&#123; abiFilter &apos;armeabi&apos;, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos; &#125; &#125; // 渠道 productFlavors &#123; &#125; signingConfigs &#123; relase &#123; storeFile file(&quot;relase.keystore&quot;) keyAlias &quot;relase&quot; keyPassword &quot;123456&quot; storePassword &quot;123456&quot; &#125; debug &#123; &#125; &#125; buildTypes &#123; release &#123; // 混淆开启 minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; debug &#123; minifyEnabled false // 4byte对齐，加快解析效率 zipAlignEnabled true // 移除无用的资源文件 shrinkResources true // 更改包名 applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; output.outputFile = new File(output.outputFile.parent, &quot;debug_&quot; + buildTime() + &quot;.apk&quot;) &#125; &#125; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:24.0.0&apos;&#125;// --------------------------------gradle.properties配置------------------------------// 加速构建速度org.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.jvmargs=-Xmx2048m// 使用ndk配置android.useDeprecatedNdk=true// 其他：1.查看 keystore 文件的签名信息：在keystore所在目录下，打开cmd:keytool -list -v -keystore keystore文件名再根据提示，输入storepassword即可查看2.混淆：https://segmentfault.com/a/1190000004461614http://www.mayflyask.org/question/247","tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://fenglincanyi.github.io/tags/Gradle/"}]},{"title":"滑动冲突之EditText-ScrollView","date":"2016-08-16T09:14:00.000Z","path":"2016/08/16/滑动冲突之EditText-ScrollView/","text":"问题一EditText的内容过多时，EditText的内容并不能滚动，而是ScrollView的滚动 解决重写EditText的onTouch事件，将触摸事件交给EditText来处理 123456789101112131415et.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; // 设置ScrollView不拦截事件 scrollView.requestDisallowInterceptTouchEvent(true); switch (event.getAction() &amp; MotionEvent.ACTION_MASK)&#123; case MotionEvent.ACTION_UP: // 手指离开时：重置ScrollView事件拦截的状态 slContainer.requestDisallowInterceptTouchEvent(false); break; &#125; return false; &#125; &#125;); &#125; 问题二若有ScrollView内容比较多，比较长时，编辑EditText里的内容时会出现ScrollView滑到底部的现象，使得当前编辑的EditText看不到了 解决修改AndroidManifest.xml中Activity的windowSoftInputMode属性 1234&lt;activity android:name=&quot;.me.MineResumeProjectExperienceActivity&quot; android:screenOrientation=&quot;portrait android:windowSoftInputMode=&quot;stateHidden|adjustPan&quot;/&gt;","tags":[{"name":"滑动冲突","slug":"滑动冲突","permalink":"https://fenglincanyi.github.io/tags/滑动冲突/"}]},{"title":"简单的页面置换算法分析","date":"2016-06-04T11:39:00.000Z","path":"2016/06/04/简单的页面置换算法分析/","text":"本文主要分析操作系统中涉及到的一些常见的置换算法，并不对涉及的操作系统内容过多介绍。这些算法在其他的计算机应用中也有体现，基本原理都是一致的，可参考理解。 一、前提说明本文主要针对一个例子进行说明，以下的算法实现过程均是按照本例进行分析。页面的走向为： 4 3 2 1 4 3 5 4 3 2 1 5 一段程序在内存中，分配3个页面，初始情况下为空。以下依次根据不同的算法进行页面置换过程的分析。 二、算法分析过程1. FIFO（先进先出）FIFO算是最简单、最容易理解的算法了，只要按照依次装入内存的页面的页号按照进入的先后次序排好队列，每次总是从队首出，队尾出。当发生缺页时，置换队首的页面即可。对上面的页面走向序列，分析过程如下图： 2. LRU （最近最少使用 Least Recently Used）在缺页发生时，选择离现在最长时间内，没有被访问过的页面置换出来。分析过程，如下图： 此算法应用的比较广泛，尤其是拿来做缓存算法。Android的API中，已经封装了相关的LRU的算法直接可以调用。 一些图片的缓存算法都是使用LRU进行缓存优化的。ImageLoader框架更是将好几种缓存算法融合到里面，可以灵活选用。详细可以查看源码的实现。3. LFU （最近最不常用 Least Frequently Used）选择访问次数最少的页面置换出来。此算法的实现要花费的开销很大，并且要确定一个合适的周期T也有一定的难度，就不在分析了。3. OPT （理想）此算法置换以后不再需要或最长时间以后才会用到的页面。这一算法一般不可能实现，但它可以作为衡量其他页面置换算法的标准。分析过程，如下图：","tags":[{"name":"LRU","slug":"LRU","permalink":"https://fenglincanyi.github.io/tags/LRU/"}]},{"title":"Android SingleTask 探究","date":"2016-05-16T03:12:00.000Z","path":"2016/05/16/Android SingleTask 探究/","text":"Android 4种启动模式来说，用法说明此处不再提及主要介绍SingleTop，SingleTask相关的问题 说明 先分析 官方文档 中的一段话： As shown in the table above, standard is the default mode and is appropriate for most types of activities. SingleTop is also a common and useful launch mode for many types of activities. The other modes — singleTask and singleInstance — are not appropriate for most applications, since they result in an interaction model that is likely to be unfamiliar to users and is very different from most other applications. &emsp;&emsp;对于大多数应用来说，SingleTask 和 SingleInstance 并不适用，standrd 和 SingleTop对于普通的大部分Activity启动是适用的。之所以使用singleTask，是存在这样一类问题，想要从后面的Activity 直接跳转到前面某一个Activity时，可能会采用的，如一个应用的MainActivity，LoginActivity等。 &emsp;&emsp;对于SingleTask模式，官方文档的这么一句话，坑了不少人（我还比较幸运，没被坑惨）,也带给我对之前知识的迷惑。 The system creates a new task and instantiates the activity at the root of the new task &emsp;&emsp;其实事实根本不是这样的！！！ 场景复现 下面用代码事实说话：建立3个Activity，分别为Main1Activity、Main2Activity、Main3Activity，前两个都设定单击事件，跳转逻辑为：main1 -&gt; main2 -&gt; main3，其中 Main2Activity 为 SingleTask（AndroidManifest.xml中设置）。打印相应的生命周期方法和所在的 taskId &emsp;&emsp;这些taskid都是一样的，所以它们都是同一个Task中的。事实胜于雄辩。然后搜了一下相关问题，老罗的博客还是给力，彻彻底底的分析了这个坑。致谢老罗的开源精神！&emsp;&emsp;链接：http://blog.csdn.net/luoshengyang/article/details/6714543 同时为了解释项目中类似的一个页面跳转问题，对于上面的demo做了修改： 将 Main1Activity 设置为 SingleTask，其余2个为standrd 操作步骤： 点击图标启动此应用 依次点击进入 Main2，Main3，再点击Home键 点击应用图标重新进入 操作结果：结果再次显示的是Main1Activity，而不是Main3Activity。 先看看打印的日志： 再次点击图标进入应用时，实际上是Main2Activity，Main3Activity 出栈了。分析下这个过程： Main1，Main2，Main3 依次压入栈中，然后 Home 键，则整个Task处于stop状态，是一个background Task。当再次点击应用图标时，系统检测到此时已经存在一个该应用的Task的，此时就将此Background Task 移至前台，成为Foreground Task，而且由于Main1Activity是SingleTask，且位于task底部，所以，再次启动时，将前两个Activity移除，且按照启动顺序依次移除，所以打出的日志是：Main2 desotry，Main3 destory，Main1 onResume。 看来，SingleTask这种特殊的模式引起的Task内Activity的变化是值得注意的 之前我在Stackoverflow上问相关的问题，和我猜想的原因比较类似，链接如下： http://stackoverflow.com/questions/36933755/activity-is-singletask-and-is-root-in-task-restrart-activity-of-top-is-destorye （可供参考） 那么，如何才能在一个新的任务栈里创建新的Activity呢？ 只需要在AndroidManifest.xml中配置即可 在SingleTask的基础之上，再增加设置 taskAffinify 属性即可，默认情况下，taskAffinity属性值为 包名，所以可以自定义一个taskAffinity值，便可以实现一个新的Task,新的Activity处于这个新的Task的root。如，我的 Demo 代码如下： 总结 SingleTask的启动模式并不会启动一个新的任务栈来承载Activity，而是在原来的Task中 SingleTask的启动模式，在官方文档的说明中，日常开发中并不建议使用，SingleInstance更是如此。 Activity的启动模式会带来的Task的变化和Activity的生命周期变化都会在ActivityRecord中体现的，通过源码分析可以发现。 通过以下命令，可以查看Task内的Activity的变化： adb shell dumpsys activity 获取所有应用的activity堆栈信息 adb shell dumpsys activity | grep com.xxx.xxx.xxx 获取某个应用的activity 堆栈信息 adb shell dumpsys activity | grep mFocusedActivity 获取处于栈顶的Activity http://blog.piasy.com/2016/03/19/Android-Task-And-Back-Stack/ (写完此文后，发现有高人已经写得很全面很详尽了)","tags":[{"name":"SingleTask","slug":"SingleTask","permalink":"https://fenglincanyi.github.io/tags/SingleTask/"}]},{"title":"对称、非对称加密技术初探","date":"2016-02-28T09:52:00.000Z","path":"2016/02/28/对称、非对称加密技术初探/","text":"一、对称加密 对称加密简介 对称加密算法所用到的基本的方法是：代换 和 置换。简单来说：（以早期的加密方式举例） 代换：是将明文字母替换成其他字母、数字或符号的方法 对于明文中的每一个字母，用字母表中k个字母来代替（允许循环，即a可以在z的后面） 例如：如果 k = 3，那么明文中的 a 在密文中就变 d ，b 就变成 e。这里 k 值充当密钥 置换：可以说对代换的一种改进，通过并不是通过固定的规则来替换字母，任意字母都可以替换为别的其他字母，但是一一对应的。例如（单表置换加密）： 明文：a b c d e f g 密文：d c h n q i a 以上是早期加密时用的简单的方法，其思想还是通过 替换 来进行加密的 对称加密过程 常见对称加密算法 DES 采用64位的分组长度，和56位的密钥长度，将64位的输入经过一系列的变换得到64位的输出。加密解密使用了相同的密钥。 * 注： 此算法可以被暴力破解，穷举即可解密，所以不再单纯使用 3DES 对DES的改进，使用多个密钥对DES进行三次加密，有些基于Internet的应用已经采纳了这种算法，如：PGP，S/MIME AES(高级加密标准) 对DES的再次改进，性能不低于3DES， 它的密钥长度为128、192或256位，分组长度为128位 Blowfish算法 一种可变密钥长度的分组加密算法，分组长度64位。迄今为止，该算法的安全性还没有受到挑战 RC5算法 参数可变的分组加密算法，此算法使用了三种运算：异或、加、循环 二、非对称加密 基于数学函数的算法，而不再是基于代换和置换技术，公钥加密算法是 非对称的 根据加密算法 和 加密密钥 是推不出 解密密钥的 关于公钥、私钥 正确理解： 公钥是用于 加密 和 认证 的 私钥是用于 解密 和 签名 的 * 这两个密钥，任意一个都可以用来加密，另一个用来解密 * 公钥是公开的 非对称加密过程 RSA简介 第一个能用于数据加密也能用于数字签名的算法，RSA是一种分组密码 易于理解和操作，但安全性一直没有得到理论上的证明 RSA的加密和解密时间是DES的上百倍，效率较低 选取密钥的过程： (1). 选取两个 大质数 p, q. 质数值越大，破解 RSA 就越困难，进行加密和解密的时间就越长 (2). 计算 n = p q, z = (p-1) (q-1) (3). 选取 e &lt; n, 且与 z 互质（e 和 z没有公约数） (4). 找到数 d, 满足 ed - 1 被 z 整除（ ((e * d) - 1) % n) == 0 ） (5). 公钥：（n, e）; 私钥：（n, d） 加密、解密过程： (1). 甲方（发送方）：发送 m (发送数)，m &lt; n, (2). 发送时，用乙方（接收方）的公钥加密：密文 c = m^e % n (3). 乙方：解密用自己的私钥，得到明文 m = c^d % n 其他非对称加密算法 ElGamal算法：基于公钥密码体制和椭圆曲线加密体系，既能用于数据加密，又能用于数字签名 背包加密算法：基于背包算法，但是大多数一次背包体制均被破译了，因此很少有人使用它 散列(哈希)函数 是公开的函数，可以将任意长的串映射成一个固定长度的串，Hash值 由下面的函数 H 生成： h = H (M) M: 变长的消息，H(M)是定长的 Hash值 常见的散列函数有： MD5，SHA-1 MD5： 有广泛的应用，如在 Java API 中就有体现，但也不安全，有人专门将大量的明文和密文收集起来存至数据库中，用于暴力破解MD5。所以实际使用时，需 “加盐” SHA-1: 在Linux系统、Git中都有广泛的使用，它的原理类似于 MD4(MD5的前身)。 说明： MD5 和 SHA-1被好多人称为 加密算法，其实这两个散列函数，是用于散列获得消息摘要的，严格来说，应该叫做 消息摘要算法 数字签名 签名是用来验证 发送方的身份 和 数据的完整性(数据是否被第三方篡改)的 签名分为： 普通数字签名（如：RSA，DES） 特殊数字签名（如：有盲签名，代理签名） 数字签名过程： (1). 发送方 生成一对公钥和私钥，将自己的 公钥 发送给 接收方 (2). 发送方 将 要发送的消息 msg, 进行散列(MD5或者SHA-1)，得到 消息摘要 (3). 发送方 将 消息摘要 用自己的私钥加密，加密后的信息就是 数字签名 (4). 发送方 将 数字签名 附在 要发送的消息 msg’ (是通过接收方的公钥加密后的) 的后面，再一起发送至 接收方数字签名的验证过程： (1). 接收方 收到消息后，对消息 msg’ 使用自己的私钥进行解密得到 msg (2). 接收方 对 数字签名 使用 发送方的公钥解密，得到 消息摘要(之前是由消息经过散列得到) (3). 接收方 使用相同的 散列函数(散列函数也是公开的)对 msg 进行散列，再计算得到一个 消息摘要 (4). 接收方 对比着两个 消息摘要 即可判断出 消息的完整性 身份的正确性：可通过 使用公钥能否解开数字签名 来判断 数据的完整性：可通过 对比两个消息摘要是否相同 来判断","tags":[{"name":"加密","slug":"加密","permalink":"https://fenglincanyi.github.io/tags/加密/"},{"name":"签名","slug":"签名","permalink":"https://fenglincanyi.github.io/tags/签名/"}]},{"title":"Git学习笔记（二）","date":"2016-02-19T08:06:00.000Z","path":"2016/02/19/Git学习笔记（二）/","text":"常用命令： 1、初始 git &lt;verb&gt; --help 查看命令用法(方法之一) git init 初始化git仓库(在当前目录下会创建.git目录) 2、 远程操作 git clone URL 从远程clone git仓库 git remote -v 查看远程仓库使用的 Git 保存的简写与其对应的 URL git pull URL 将数据拉取到你的本地仓库,并合并远程分支到当前分支 git fetch URL 将数据拉取到你的本地仓库,并不会自动合并或修改你当前的工作 git push URL 将本地git仓库推送到远程仓库(一次就记住URL了,之后不需要写URL) 3、添加文件 git add filename 添加某个文件(该文件处于已跟踪(A)：tracked) git add --all , -A 添加所有文件 4、提交文件 git commit -m &quot;提交信息&quot; 提交当下工作区的文件 git commit -a -m &quot;提交信息&quot; 前两个命令的合并，直接跳过暂存区提交 git commit 启动文本编辑器写提交信息 5、查看文件状态 git status 查看当前文件状态 git status -s 查看当前文件详细状态列表 6、查看日志 git log 查看提交的日志 git log --oneline 查看提交的日志简略信息 git log -p -2 查看最近两次提交的日志 7、查看修改 git diff 查看未暂存文件(未add)的修改内容 git diff --staged, --cached 查看已暂存文件(已add)的修改内容 8、删除文件 git rm filename 移除文件 git rm --cached filename 移除文件,但该文件还留在工作区，但之后不会被跟踪(untracked) git rm \\*.txt 移除以 .txt 结尾的文件 9、更改文件名 git mv oldName newName 更改文件名 10、标签操作 git tag -a v1.0 -m &quot;info&quot; 打标签 v1.0:版本号，info:版本信息 git tag 查看已有标签 11、分支操作 git branch branchName 创建分支 git branch -d branchName 删除分支 git checkout branchName 切换分支 git merge branchName 合并分支到当前分支 git mergetool 启动图形化工具解决冲突 git branch 查看所有分支 git branch -v, -vv 查看所有分支的最后一次提交 补充： rebase: 变基，另一种不同于merge的”整合”方式 (命令示例：git rebase master) 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 请注意： 无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 准则： 不要对在你的仓库外有副本的分支执行变基 只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作","tags":[{"name":"Git","slug":"Git","permalink":"https://fenglincanyi.github.io/tags/Git/"}]},{"title":"Git学习笔记（一）","date":"2016-02-19T07:28:00.000Z","path":"2016/02/19/Git学习笔记（一）/","text":"一、Git特点1. 直接记录快照，而非差异比较 在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。2. 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。3. Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。SHA-1 哈希看起来是这样： &gt;24b9da6552252987aa493b52f8696cd6d3b00373 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 4. Git 一般只添加数据 你执行的 Git 操作，几乎只往 Git 数据库中增加数据 二、Git 中的文件有3种状态：1. 已提交：数据已经安全的保存在本地数据库中2. 已修改：修改了文件，但未保存到数据库中3. 已暂存：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 三、Git 中的3个工作区域1. Git仓库：保存项目的元数据和对象数据库，Git中最重要的部分，供其他人clone 仓库2. 工作目录：对项目的某个版本独立提取出来的，供工作中使用、修改 工作目录下的文件状态： 已跟踪：纳入了版本控制的文件，后期可能处于 未修改，已修改或放入暂存区了 未跟踪：工作目录下除已跟踪文件外的其他所有文件 3. 暂存区：是一个文件，保存下次将提交的文件列表信息，一般在Git仓库目录中，有时也被叫做索引 四、Git 的基本工作流程1. 在工作目录中修改文件2. 暂存文件，将文件的快照放入暂存区3. 提交更新，找到暂存区的文件，将快照永久性存储到Git仓库中五、Git 个人信息初始配置 全局信息配置：(个人默认信息) git config –global user.name “xxx” git config –global user.email xxx@qq.coom 此配置会写入 user目录下的 .gitconfig文件，实际上为个人信息默认值 临时配置： 去掉 –global 即可 实际是在其配置列表中追加其信息，重复变量名，不同的value值 (Git每次会读取不同文件，其中就可能含有同一个配置) Git 会使用每个变量的最后一次的配置的值","tags":[{"name":"Git","slug":"Git","permalink":"https://fenglincanyi.github.io/tags/Git/"}]},{"title":"Android Studio NDK开发环境搭建及Demo示例","date":"2016-01-16T11:34:00.000Z","path":"2016/01/16/Android Studio NDK开发环境搭建及Demo示例/","text":"说明：Android Studio 1.4后支持C/C++开发，1.3之前的版本坑点较多，所以使用1.4后的版本较为容易 所用工具版本 Android Studio 1.5 android-ndk-r10e-windows-x86_64.exe 配置NDK环境 自行下载 ndk 工具，在你的要安装 ndk 的目录下，直接双击 此安装包，就会自动安装至此目录下，过程中会打开cmd窗口，命令行不断执行命令，需等待一会即可 cmd窗口自动关闭后，会出现 ndk 的文件夹，如图： 配置ndk环境变量，path 中添加即可，如我的路径如下： PATH： D:\\android-ndk-r10e 保存后，打开cmd,输入命令: ndk-build 出现如下显示，则安装成功： 第一个NDKDemo studio中，新建一个project， name： NDKDemo 在本项目中，配置 ndk 路径，如图： 点击OK， 此时，等待gradle构建，构建完成后，观察 local.properties 文件，多出来了 ndk 的路径，如图所示： 打开 grade.properties 文件，在末尾添加： android.useDeprecatedNdk=”true” ![](http://7xr1vo.com1.z0.glb.clouddn.com/7.png) * 此步骤，为了防止下一步修改 app/build.gradle 文件后报错 打开 app/build.gradle 文件，在 defaultConfig 下加入ndk相关配置参数： ndk { moduleName &quot;HelloNDK&quot; } * 此处的 modleName 是 加载库文件的标识，必须和后面代码中的 System.loadLibrary(&quot;HelloNDK&quot;) 保持一致，否则会报错 书写 native 方法 和 加载类库，代码如下： static { // 加载类库 System.loadLibrary(&quot;HelloNDK&quot;); } // native方法 调用 C代码 public native String javaCallC(); 如图，我这是后续的图片，过程中的未截： 打开左下角的 Terminal，cd 至 java 路径下，并执行命令： javah -d jni [native方法所在类的全路径] 如图： * 在studio中：类的全路径可 通过 右击该类 -&gt; Copy Reference获得 执行成功后，刷新下目录，可看到目录中多了一个 咖啡色的jni目录，和一个 .h文件，如图： 右击 Main目录的图标 -&gt; New -&gt; Floder -&gt; JNI Floder，之后会出现一个 蓝色的JNI 文件夹，如图： 此时，继续解决上面 native 方法名报错（红色）的问题，Alt + Enter 选择创建 .c 中的方法，这时，会在蓝色的JNI文件夹下自动生成一个 .c 文件，并且 含有 c代码，里面有复杂的方法头 * 可能 native 方法名仍然是红色的，这可能是 Studio 的一个bug，但其实是可以运行的。可能过一段时间红色会消失变为正常，我的就是这种情况 下面就可以书写真正的 C代码了，此处 只简单写下，关于更牛逼的用法，将更新在后面blog中，继续总结。 此处代码改为： return (*env)-&gt;NewStringUTF(env, &quot;你好，NDK&quot;); OK，第一个NDK Demo可以运行了，上图： 总结 相比以前在 eclipse 中进行 NDK 开发，studio中显得方便多了，并不用安装 CDT 和 cygwin，而且 .c 文件及其内容可以自动生成 利用命令 javah -d jni [native方法所在类的全路径] 生成的 .h头文件 可以在 有了 .c 文件后删除，此 .h 文件主要是用来用于生成 .c 文件中相应比较长的方法头。如果之前没有 .h 文件，Alt + Enter 是无法自动生成 .c文件的 必须在 有 /src/main/jni 的文件夹（蓝色的jni文件夹）下，才能自动生成.c 文件 .c 文件中要出现了中文，必须是 UTF-8 下，否则，运行时会崩溃报错 注意观察 /app/build/intermediates/ndk 目录下，有相关的 所有平台的 .so 文件（默认情况下，生成所有平台的；若只想生成某几种平台的，可在 app/build.gradle（abi-Filters “armeabi”,”armeabi-v7a”,”x86”） 中 或者 Android.mk中 进行配置） 补充 so文件和native类与混淆无关，无需keep语句 实现类一定要方法名正确否则会报java.lang.UnsatisfiedLinkError: dlopen failed异常 studio工具的提示并不是很智能，所以有时要rebuild project","tags":[{"name":"JNI","slug":"JNI","permalink":"https://fenglincanyi.github.io/tags/JNI/"},{"name":"NDK","slug":"NDK","permalink":"https://fenglincanyi.github.io/tags/NDK/"}]}]